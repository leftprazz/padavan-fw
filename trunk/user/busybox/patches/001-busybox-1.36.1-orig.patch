diff -urN busybox-1.36.1-ref/Makefile busybox-1.36.1/Makefile
--- busybox-1.36.1-ref/Makefile	2023-05-19 01:31:00.000000000 +0300
+++ busybox-1.36.1/Makefile	2023-05-19 23:01:27.841392431 +0300
@@ -278,8 +278,8 @@
 # We need some generic definitions
 include $(srctree)/scripts/Kbuild.include
 
-HOSTCFLAGS	+= $(call hostcc-option,-Wall -Wstrict-prototypes -O2 -fomit-frame-pointer,)
-HOSTCXXFLAGS	+= -O2
+HOSTCFLAGS	+= $(call hostcc-option,-Wall -Wstrict-prototypes -Os -fomit-frame-pointer,)
+HOSTCXXFLAGS	+= -Os
 
 # For maximum performance (+ possibly random breakage, uncomment
 # the following)
diff -urN busybox-1.36.1-ref/debianutils/start_stop_daemon.c busybox-1.36.1/debianutils/start_stop_daemon.c
--- busybox-1.36.1-ref/debianutils/start_stop_daemon.c	2023-01-03 16:14:43.000000000 +0200
+++ busybox-1.36.1/debianutils/start_stop_daemon.c	2023-05-19 23:01:27.841392431 +0300
@@ -549,16 +549,8 @@
 	if (opt & OPT_c) {
 		struct bb_uidgid_t ugid;
 		parse_chown_usergroup_or_die(&ugid, chuid);
-		if (ugid.uid != (uid_t) -1L) {
-			struct passwd *pw = xgetpwuid(ugid.uid);
-			if (ugid.gid != (gid_t) -1L)
-				pw->pw_gid = ugid.gid;
-			/* initgroups, setgid, setuid: */
-			change_identity(pw);
-		} else if (ugid.gid != (gid_t) -1L) {
-			xsetgid(ugid.gid);
-			setgroups(1, &ugid.gid);
-		}
+		if (ugid.gid != (gid_t) -1L) xsetgid(ugid.gid);
+		if (ugid.uid != (uid_t) -1L) xsetuid(ugid.uid);
 	}
 	/* Try:
 	 * strace -oLOG start-stop-daemon -S -x /bin/usleep -a qwerty 500000
diff -urN busybox-1.36.1-ref/include/volume_id.h busybox-1.36.1/include/volume_id.h
--- busybox-1.36.1-ref/include/volume_id.h	2021-01-01 12:52:27.000000000 +0200
+++ busybox-1.36.1/include/volume_id.h	2023-05-19 23:01:27.841392431 +0300
@@ -26,6 +26,7 @@
  * 0: no UUID= or LABEL= prefix found
  * 1: UUID= or LABEL= prefix found. In this case,
  *    *fsname is replaced if device with such UUID or LABEL is found
+ * -2: UUID= or LABEL= prefixes cannot be resolved
  */
 int resolve_mount_spec(char **fsname);
 int add_to_uuid_cache(const char *device);
diff -urN busybox-1.36.1-ref/libbb/Kbuild.src busybox-1.36.1/libbb/Kbuild.src
--- busybox-1.36.1-ref/libbb/Kbuild.src	2023-01-03 16:14:43.000000000 +0200
+++ busybox-1.36.1/libbb/Kbuild.src	2023-05-19 23:01:27.845392295 +0300
@@ -140,6 +140,7 @@
 lib-$(CONFIG_UDPSVD) += udp_io.o
 lib-$(CONFIG_TRACEROUTE) += udp_io.o
 lib-$(CONFIG_TRACEROUTE6) += udp_io.o
+lib-$(CONFIG_DHCP6C) += udp_io.o
 
 lib-$(CONFIG_LOSETUP) += loop.o
 lib-$(CONFIG_FEATURE_MOUNT_LOOP) += loop.o
diff -urN busybox-1.36.1-ref/libbb/appletlib.c busybox-1.36.1/libbb/appletlib.c
--- busybox-1.36.1-ref/libbb/appletlib.c	2023-01-03 16:14:43.000000000 +0200
+++ busybox-1.36.1/libbb/appletlib.c	2023-05-19 23:01:27.845392295 +0300
@@ -692,12 +692,6 @@
 			continue;
 	}
 }
-# elif ENABLE_BUSYBOX
-static void install_links(const char *busybox UNUSED_PARAM,
-		int use_symbolic_links UNUSED_PARAM,
-		char *custom_install_dir UNUSED_PARAM)
-{
-}
 # endif
 
 # if ENABLE_BUSYBOX || NUM_APPLETS > 0
@@ -865,7 +859,8 @@
 		return 0;
 	}
 
-	if (ENABLE_FEATURE_INSTALLER && strcmp(argv[1], "--install") == 0) {
+# if ENABLE_FEATURE_INSTALLER
+	if (strcmp(argv[1], "--install") == 0) {
 		int use_symbolic_links;
 		const char *busybox;
 
@@ -888,6 +883,7 @@
 		install_links(busybox, use_symbolic_links, argv[2]);
 		return 0;
 	}
+# endif
 
 	if (strcmp(argv[1], "--help") == 0) {
 		/* "busybox --help [<applet>]" */
diff -urN busybox-1.36.1-ref/libbb/bb_strtonum.c busybox-1.36.1/libbb/bb_strtonum.c
--- busybox-1.36.1-ref/libbb/bb_strtonum.c	2021-01-01 12:52:27.000000000 +0200
+++ busybox-1.36.1/libbb/bb_strtonum.c	2023-05-19 23:01:27.845392295 +0300
@@ -55,13 +55,16 @@
 {
 	unsigned long long v;
 	char *endptr;
+	char first;
 
 	if (!endp) endp = &endptr;
 	*endp = (char*) arg;
 
 	/* strtoul("  -4200000000") returns 94967296, errno 0 (!) */
 	/* I don't think that this is right. Preventing this... */
-	if (!isalnum(arg[0])) return ret_ERANGE();
+	//if (!isalnum(arg[0])) return ret_ERANGE();
+	first = (arg[0] != '-' ? arg[0] : arg[1]);
+	if (!isalnum(first)) return ret_ERANGE();
 
 	/* not 100% correct for lib func, but convenient for the caller */
 	errno = 0;
@@ -94,11 +97,14 @@
 {
 	unsigned long v;
 	char *endptr;
+	char first;
 
 	if (!endp) endp = &endptr;
 	*endp = (char*) arg;
 
-	if (!isalnum(arg[0])) return ret_ERANGE();
+	first = (arg[0] != '-' ? arg[0] : arg[1]);
+	if (!isalnum(first)) return ret_ERANGE();
+
 	errno = 0;
 	v = strtoul(arg, endp, base);
 	return handle_errors(v, endp);
@@ -127,11 +133,14 @@
 {
 	unsigned long v;
 	char *endptr;
+	char first;
 
 	if (!endp) endp = &endptr;
 	*endp = (char*) arg;
 
-	if (!isalnum(arg[0])) return ret_ERANGE();
+	first = (arg[0] != '-' ? arg[0] : arg[1]);
+	if (!isalnum(first)) return ret_ERANGE();
+
 	errno = 0;
 	v = strtoul(arg, endp, base);
 	if (v > UINT_MAX) return ret_ERANGE();
diff -urN busybox-1.36.1-ref/libbb/find_pid_by_name.c busybox-1.36.1/libbb/find_pid_by_name.c
--- busybox-1.36.1-ref/libbb/find_pid_by_name.c	2021-01-01 12:52:27.000000000 +0200
+++ busybox-1.36.1/libbb/find_pid_by_name.c	2023-05-19 23:01:27.845392295 +0300
@@ -85,16 +85,10 @@
 	procps_status_t* p = NULL;
 
 	pidList = xzalloc(sizeof(*pidList));
-	while ((p = procps_scan(p, PSSCAN_PID|PSSCAN_COMM|PSSCAN_ARGVN|PSSCAN_EXE))) {
+	while ((p = procps_scan(p, PSSCAN_PID|PSSCAN_COMM|PSSCAN_ARGVN))) {
 		if (comm_match(p, procName)
 		/* or we require argv0 to match (essential for matching reexeced /proc/self/exe)*/
 		 || (p->argv0 && strcmp(bb_basename(p->argv0), procName) == 0)
-		/* or we require /proc/PID/exe link to match */
-		 || (p->exe && strcmp(
-					procName[0] == '/' ? p->exe /* support "pidof /path/to/binary" case too */
-							: bb_basename(p->exe),
-					procName
-					) == 0)
 		) {
 			pidList = xrealloc_vector(pidList, 2, i);
 			pidList[i++] = p->pid;
diff -urN busybox-1.36.1-ref/libbb/udp_io.c busybox-1.36.1/libbb/udp_io.c
--- busybox-1.36.1-ref/libbb/udp_io.c	2021-01-01 12:52:27.000000000 +0200
+++ busybox-1.36.1/libbb/udp_io.c	2023-05-19 23:01:27.849392159 +0300
@@ -24,6 +24,7 @@
 #endif
 #if ENABLE_FEATURE_IPV6 && defined(IPV6_RECVPKTINFO)
 	setsockopt_1(fd, IPPROTO_IPV6, IPV6_RECVPKTINFO);
+	setsockopt_1(fd, IPPROTO_IPV6, IPV6_2292PKTINFO);
 #endif
 }
 
@@ -80,7 +81,12 @@
 	 * was seen showing IPv6 "from" even when the destination
 	 * of received packet (our local address) was IPv4.
 	 */
-	if (/* to->sa_family == AF_INET && */ from->sa_family == AF_INET) {
+# if ENABLE_FEATURE_IPV6
+	if ((to->sa_family == AF_INET || to->sa_family == AF_INET6)
+# else
+	if ((to->sa_family == AF_INET)
+# endif
+	    && from->sa_family == AF_INET) {
 		struct in_pktinfo *pktptr;
 		cmsgptr->cmsg_level = IPPROTO_IP;
 		cmsgptr->cmsg_type = IP_PKTINFO;
@@ -172,14 +178,19 @@
 		}
 # if ENABLE_FEATURE_IPV6 && defined(IPV6_PKTINFO)
 		if (cmsgptr->cmsg_level == IPPROTO_IPV6
-		 && cmsgptr->cmsg_type == IPV6_PKTINFO
-		) {
+		 && (cmsgptr->cmsg_type == IPV6_PKTINFO
+#if defined(IPV6_2292PKTINFO) && defined(IPV6_RECVPKTINFO)
+            		 || cmsgptr->cmsg_type == IPV6_2292PKTINFO
+#endif
+		)) {
 			const int IPI6_ADDR_OFF = offsetof(struct in6_pktinfo, ipi6_addr);
+			const int IPI6_IFINDEX_OFF = offsetof(struct in6_pktinfo, ipi6_ifindex);
 			to->sa_family = AF_INET6;
 			/*#  define pktinfo(cmsgptr) ( (struct in6_pktinfo*)(CMSG_DATA(cmsgptr)) )*/
 			/*to6->sin6_addr = pktinfo(cmsgptr)->ipi6_addr; - may be unaligned */
 			memcpy(&to6->sin6_addr, (char*)(CMSG_DATA(cmsgptr)) + IPI6_ADDR_OFF, sizeof(to6->sin6_addr));
 			/*to6->sin6_port = 123; */
+			move_from_unaligned_int(to6->sin6_scope_id, (char*)(CMSG_DATA(cmsgptr)) + IPI6_IFINDEX_OFF);
 			break;
 		}
 # endif
diff -urN busybox-1.36.1-ref/modutils/insmod.c busybox-1.36.1/modutils/insmod.c
--- busybox-1.36.1-ref/modutils/insmod.c	2021-01-01 12:52:27.000000000 +0200
+++ busybox-1.36.1/modutils/insmod.c	2023-05-19 23:01:27.849392159 +0300
@@ -20,6 +20,8 @@
 
 #include "libbb.h"
 #include "modutils.h"
+#include <sys/utsname.h>
+#include <fnmatch.h>
 
 /* 2.6 style insmod has no options and required filename
  * (not module name - .ko can't be omitted) */
@@ -47,8 +49,11 @@
 int insmod_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int insmod_main(int argc UNUSED_PARAM, char **argv)
 {
+	struct utsname uts;
+	struct stat st;
 	char *filename;
-	int rc;
+	FILE *fp = NULL;
+	int rc, pos;
 
 	/* Compat note:
 	 * 2.6 style insmod has no options and required filename
@@ -67,6 +72,28 @@
 	if (!filename)
 		bb_show_usage();
 
+	/* Get a filedesc for the module.  Check we we have a complete path */
+	if (stat(filename, &st) < 0 || !S_ISREG(st.st_mode) ||
+		(fp = fopen(filename, "r")) == NULL) {
+                /* Hmm.  Could not open it.  First search under /lib/modules/`uname -r` */
+    		xchdir("/lib/modules");
+	        uname(&uts);
+    		xchdir(uts.release);
+
+		pos = strlen(filename) - 2;
+		if (get_linux_version_code() < KERNEL_VERSION(2,6,0)) {
+			if (pos < 0) pos = 0;
+			if (strncmp(&filename[pos], ".o", 2) !=0 )
+				filename = xasprintf("%s.o", filename);
+		} else {
+			if (--pos < 0) pos = 0;
+			if (strncmp(&filename[pos], ".ko", 3) !=0 )
+				filename = xasprintf("%s.ko", filename);
+		}
+	}
+	if (fp != NULL)
+		fclose(fp);
+
 	rc = bb_init_module(filename, parse_cmdline_module_options(argv, /*quote_spaces:*/ 0));
 	if (rc)
 		bb_error_msg("can't insert '%s': %s", filename, moderror(rc));
diff -urN busybox-1.36.1-ref/modutils/modutils-24.c busybox-1.36.1/modutils/modutils-24.c
--- busybox-1.36.1-ref/modutils/modutils-24.c	2023-01-03 16:14:43.000000000 +0200
+++ busybox-1.36.1/modutils/modutils-24.c	2023-05-19 23:01:27.849392159 +0300
@@ -795,7 +795,7 @@
 arch_apply_relocation(struct obj_file *f,
 		struct obj_section *targsec,
 		/*struct obj_section *symsec,*/
-		struct obj_symbol *sym,
+		struct obj_symbol *sym PLTGOT_UNUSED_PARAM,
 		ElfW(RelM) *rel, ElfW(Addr) v)
 {
 #if defined(__arm__) || defined(__i386__) || defined(__mc68000__) \
@@ -1764,7 +1764,7 @@
 
 #endif
 
-static void arch_create_got(struct obj_file *f)
+static void arch_create_got(struct obj_file *f PLTGOT_UNUSED_PARAM)
 {
 #if defined(USE_GOT_ENTRIES) || defined(USE_PLT_ENTRIES)
 	struct arch_file *ifile = (struct arch_file *) f;
@@ -3826,7 +3826,7 @@
 		/* Load module into memory and unzip if compressed */
 		image = xmalloc_open_zipped_read_close(m_filename, &image_size);
 		if (!image)
-			return EXIT_FAILURE;
+			return (-errno);
 	}
 
 	m_name = xstrdup(bb_basename(m_filename));
@@ -3857,10 +3857,12 @@
 				"\twhile this kernel is version %s",
 				flag_force_load ? "warning: " : "",
 				m_name, m_strversion, uts.release);
-			if (!flag_force_load)
+			if (!flag_force_load) {
+				exit_status = ESRCH;
 				goto out;
 		}
 	}
+	}
 #endif
 
 	if (query_module(NULL, 0, NULL, 0, NULL))
diff -urN busybox-1.36.1-ref/modutils/modutils.h busybox-1.36.1/modutils/modutils.h
--- busybox-1.36.1-ref/modutils/modutils.h	2021-01-01 12:52:27.000000000 +0200
+++ busybox-1.36.1/modutils/modutils.h	2023-05-19 23:01:27.849392159 +0300
@@ -101,6 +101,11 @@
 
 #if ENABLE_FEATURE_2_4_MODULES
 int FAST_FUNC bb_init_module_24(const char *module, const char *options);
+# if defined(USE_GOT_ENTRIES) || defined(USE_PLT_ENTRIES)
+# define PLTGOT_UNUSED_PARAM
+# else
+# define PLTGOT_UNUSED_PARAM	UNUSED_PARAM
+# endif
 #endif
 
 POP_SAVED_FUNCTION_VISIBILITY
diff -urN busybox-1.36.1-ref/networking/arping.c busybox-1.36.1/networking/arping.c
--- busybox-1.36.1-ref/networking/arping.c	2023-01-03 16:14:43.000000000 +0200
+++ busybox-1.36.1/networking/arping.c	2023-05-19 23:01:27.849392159 +0300
@@ -28,7 +28,7 @@
 //usage:     "\n	-c N		Stop after sending N ARP requests"
 //usage:     "\n	-w TIMEOUT	Seconds to wait for ARP reply"
 //NB: in iputils-s20160308, iface is mandatory, no default
-//usage:     "\n	-I IFACE	Interface to use (default eth0)"
+//usage:     "\n	-I IFACE	Interface to use (default br0)"
 //usage:     "\n	-s SRC_IP	Sender IP address"
 //usage:     "\n	DST_IP		Target IP address"
 
@@ -294,7 +294,7 @@
 int arping_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int arping_main(int argc UNUSED_PARAM, char **argv)
 {
-	const char *device = "eth0";
+	const char *device = "br0";
 	char *source = NULL;
 	char *target;
 	char *err_str;
diff -urN busybox-1.36.1-ref/networking/ntpd.c busybox-1.36.1/networking/ntpd.c
--- busybox-1.36.1-ref/networking/ntpd.c	2023-01-03 16:14:43.000000000 +0200
+++ busybox-1.36.1/networking/ntpd.c	2023-05-19 23:01:27.853392023 +0300
@@ -72,7 +72,7 @@
 //kbuild:lib-$(CONFIG_NTPD) += ntpd.o
 
 //usage:#define ntpd_trivial_usage
-//usage:	"[-dnqNw"IF_FEATURE_NTPD_SERVER("l] [-I IFACE")"] [-S PROG]"
+//usage:	"[-dnqNwt"IF_FEATURE_NTPD_SERVER("l -I IFACE")"] [-S PROG]"
 //usage:	IF_NOT_FEATURE_NTP_AUTH(" [-p PEER]...")
 //usage:	IF_FEATURE_NTP_AUTH(" [-k KEYFILE] [-p [keyno:N:]PEER]...")
 //usage:#define ntpd_full_usage "\n\n"
@@ -82,6 +82,7 @@
 //usage:     "\n	-q	Quit after clock is set"
 //usage:     "\n	-N	Run at high priority"
 //usage:     "\n	-w	Do not set time (only query peers), implies -n"
+//usage:     "\n	-t	Trust network and server, no RFC-4330 cross-checks"
 //usage:     "\n	-S PROG	Run PROG after stepping time, stratum change, and every 11 min"
 //usage:	IF_NOT_FEATURE_NTP_AUTH(
 //usage:     "\n	-p PEER	Obtain time from PEER (may be repeated)"
@@ -160,7 +161,7 @@
  *   datapoints after the step.
  */
 
-#define INITIAL_SAMPLES    3    /* how many samples do we want for init */
+#define INITIAL_SAMPLES    2    /* how many samples do we want for init */
 #define MIN_FREQHOLD      10    /* adjust offset, but not freq in this many first adjustments */
 #define BAD_DELAY_GROWTH   4    /* drop packet if its delay grew by more than this factor */
 
@@ -196,7 +197,7 @@
  * then it is decreased _at once_. (If <= 2^BIGPOLL, it will be decreased _eventually_).
  */
 #define BIGPOLL         9       /* 2^9 sec ~= 8.5 min */
-#define MAXPOLL         12      /* maximum poll interval (12: 1.1h, 17: 36.4h). std ntpd uses 17 */
+#define MAXPOLL         16      /* maximum poll interval (12: 1.1h, 17: 36.4h). std ntpd uses 17 */
 /* Actively lower poll when we see such big offsets.
  * With SLEW_THRESHOLD = 0.125, it means we try to sync more aggressively
  * if offset increases over ~0.04 sec
@@ -370,10 +371,11 @@
 	/* Insert new options above this line. */
 	/* Non-compat options: */
 	OPT_w = (1 << (4+ENABLE_FEATURE_NTP_AUTH)),
-	OPT_p = (1 << (5+ENABLE_FEATURE_NTP_AUTH)),
-	OPT_S = (1 << (6+ENABLE_FEATURE_NTP_AUTH)),
-	OPT_l = (1 << (7+ENABLE_FEATURE_NTP_AUTH)) * ENABLE_FEATURE_NTPD_SERVER,
-	OPT_I = (1 << (8+ENABLE_FEATURE_NTP_AUTH)) * ENABLE_FEATURE_NTPD_SERVER,
+	OPT_t = (1 << (5+ENABLE_FEATURE_NTP_AUTH)),
+	OPT_p = (1 << (6+ENABLE_FEATURE_NTP_AUTH)),
+	OPT_S = (1 << (7+ENABLE_FEATURE_NTP_AUTH)),
+	OPT_l = (1 << (8+ENABLE_FEATURE_NTP_AUTH)) * ENABLE_FEATURE_NTPD_SERVER,
+	OPT_I = (1 << (9+ENABLE_FEATURE_NTP_AUTH)) * ENABLE_FEATURE_NTPD_SERVER,
 	/* We hijack some bits for other purposes */
 	OPT_qq = (1 << 31),
 };
@@ -1129,6 +1131,9 @@
 				"unreachable", p->p_dotted);
 		return 0;
 	}
+	if (option_mask32 & OPT_t) /* RFC-4330 check disabled */
+		return 1;
+
 #if 0 /* we filter out such packets earlier */
 	if ((p->lastpkt_status & LI_ALARM) == LI_ALARM
 	 || p->lastpkt_stratum >= MAXSTRAT
@@ -1517,6 +1522,7 @@
 		VERB4 bb_error_msg("stepping time by %+f; poll_exp=MINPOLL", offset);
 		step_time(offset);
 		if (option_mask32 & OPT_q) {
+			run_script("step", offset);
 			/* We were only asked to set time once. Done. */
 			exit(0);
 		}
@@ -1535,6 +1541,7 @@
 			/* We were only asked to set time once.
 			 * The clock is precise enough, no need to step.
 			 */
+			run_script("step", offset);
 			exit(0);
 		}
 
@@ -1880,9 +1887,10 @@
 	close(p->p_fd);
 	p->p_fd = -1;
 
-	if ((msg.m_status & LI_ALARM) == LI_ALARM
+	if (!(option_mask32 & OPT_t) /* RFC-4330 check enabled by default */
+	 && ((msg.m_status & LI_ALARM) == LI_ALARM
 	 || msg.m_stratum == 0
-	 || msg.m_stratum > NTP_MAXSTRATUM
+	 || msg.m_stratum > NTP_MAXSTRATUM)
 	) {
 		bb_error_msg("reply from %s: peer is unsynced", p->p_dotted);
 		/*
@@ -2275,7 +2283,7 @@
 	opts = getopt32(argv, "^"
 			"nqNx" /* compat */
 			IF_FEATURE_NTP_AUTH("k:")  /* compat */
-			"wp:*S:"IF_FEATURE_NTPD_SERVER("l") /* NOT compat */
+			"wtp:*S:"IF_FEATURE_NTPD_SERVER("l") /* NOT compat */
 			IF_FEATURE_NTPD_SERVER("I:") /* compat */
 			"d" /* compat */
 			"46aAbgL" /* compat, ignored */
diff -urN busybox-1.36.1-ref/networking/traceroute.c busybox-1.36.1/networking/traceroute.c
--- busybox-1.36.1-ref/networking/traceroute.c	2021-09-30 01:04:47.000000000 +0300
+++ busybox-1.36.1/networking/traceroute.c	2023-05-19 23:01:27.853392023 +0300
@@ -972,7 +972,7 @@
 		xmove_fd(xsocket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6), rcvsock);
 # if ENABLE_FEATURE_TRACEROUTE_VERBOSE
 		/* want recvmsg to report target local address (for -v) */
-		setsockopt_1(rcvsock, SOL_IPV6, IPV6_RECVPKTINFO);
+		socket_want_pktinfo(rcvsock);
 # endif
 	}
 #endif
diff -urN busybox-1.36.1-ref/networking/udhcp/Config.src busybox-1.36.1/networking/udhcp/Config.src
--- busybox-1.36.1-ref/networking/udhcp/Config.src	2023-01-03 16:14:43.000000000 +0200
+++ busybox-1.36.1/networking/udhcp/Config.src	2023-05-19 23:01:27.853392023 +0300
@@ -129,7 +129,7 @@
 	int "Maximum verbosity level (0..9)"
 	default 2
 	range 0 9
-	depends on UDHCPD || UDHCPC || UDHCPC6 || DHCPRELAY
+	depends on UDHCPD || UDHCPC || UDHCPC6 || DHCPRELAY || DHCP6C
 	help
 	Verbosity can be increased with multiple -v options.
 	This option controls how high it can be cranked up.
@@ -163,7 +163,7 @@
 config FEATURE_UDHCP_RFC3397
 	bool "Support RFC 3397 domain search options"
 	default y
-	depends on UDHCPD || UDHCPC
+	depends on UDHCPD || UDHCPC || DHCP6C
 	help
 	If selected, both client and server will support passing of domain
 	search lists via option 119, specified in RFC 3397,
@@ -176,3 +176,26 @@
 	help
 	If selected, both client and server will support passing of VLAN
 	ID and priority via options 132 and 133 as per 802.1Q.
+
+config FEATURE_UDHCP_RFC5969
+	bool "Support for RFC5969 IPv6 Rapid Deployment (6RD)"
+	default y
+	depends on FEATURE_IPV6 && UDHCPC
+	help
+	  None.
+
+config DHCP6C
+	bool "DHCPv6 client daemon (dhcp6c)"
+	default n
+	depends on PLATFORM_LINUX && FEATURE_IPV6
+	help
+	  dhcp6c is a DHCPv6 client geared primarily toward embedded systems,
+	  while striving to be fully functional and RFC compliant.
+
+config FEATURE_DHCP6_AUTH
+	bool "Support DHCPv6 messages authentication"
+	default n
+	depends on DHCP6C
+	help
+	  If selected, client will support DHCPv6 messages authentication,
+	  currently HMAC-MD5 only.
diff -urN busybox-1.36.1-ref/networking/udhcp/common.c busybox-1.36.1/networking/udhcp/common.c
--- busybox-1.36.1-ref/networking/udhcp/common.c	2023-01-03 16:14:43.000000000 +0200
+++ busybox-1.36.1/networking/udhcp/common.c	2023-05-19 23:01:27.853392023 +0300
@@ -69,7 +69,10 @@
 	{ OPTION_STRING                           , 0xd1 }, /* DHCP_PXE_CONF_FILE */
 	{ OPTION_STRING                           , 0xd2 }, /* DHCP_PXE_PATH_PREFIX */
 	{ OPTION_U32                              , 0xd3 }, /* DHCP_REBOOT_TIME   */
+#if ENABLE_FEATURE_UDHCP_RFC5969
+	{ OPTION_6RD                              , 0x96 }, /* DHCP_COMCAST_6RD   */
 	{ OPTION_6RD                              , 0xd4 }, /* DHCP_6RD           */
+#endif
 	{ OPTION_STATIC_ROUTES | OPTION_LIST      , 0xf9 }, /* DHCP_MS_STATIC_ROUTES */
 	{ OPTION_STRING                           , 0xfc }, /* DHCP_WPAD          */
 
diff -urN busybox-1.36.1-ref/networking/udhcp/common.h busybox-1.36.1/networking/udhcp/common.h
--- busybox-1.36.1-ref/networking/udhcp/common.h	2023-01-03 16:14:43.000000000 +0200
+++ busybox-1.36.1/networking/udhcp/common.h	2023-05-19 23:01:27.857391888 +0300
@@ -183,6 +183,8 @@
 //#define DHCP_PXE_PATH_PREFIX  0xd2 /* 210: RFC 5071 Path prefix */
 //#define DHCP_REBOOT_TIME      0xd3 /* 211: RFC 5071 Reboot time */
 //#define DHCP_MS_STATIC_ROUTES 0xf9 /* 249: Microsoft's pre-RFC 3442 code for 0x79? */
+//#define DHCP_6RD              0xd4 /* RFC 5969 6RD option */
+//#define DHCP_COMCAST_6RD      0x96 /* Comcast ISP RFC 5969 compatible 6RD option */
 //#define DHCP_WPAD             0xfc /* 252: MSIE's Web Proxy Autodiscovery Protocol */
 #define DHCP_END                0xff /* 255: */
 
@@ -327,6 +329,8 @@
 
 /*** Other shared functions ***/
 
+int FAST_FUNC sprint_nip6(char *, const uint8_t *);
+
 /* 2nd param is "uint32_t*" */
 int FAST_FUNC udhcp_str2nip(const char *str, void *arg);
 
@@ -370,8 +374,8 @@
 void udhcp_sp_fd_set(struct pollfd *pfds, int extra_fd) FAST_FUNC;
 int udhcp_sp_read(void) FAST_FUNC;
 
 int udhcp_read_interface(const char *interface,
-		int *ifindex, uint32_t *nip, uint8_t *mac) FAST_FUNC;
+		int *ifindex, uint32_t *nip, uint8_t *mac, uint16_t *mtu) FAST_FUNC;

 int udhcp_listen_socket(/*uint32_t ip,*/ int port, const char *inf) FAST_FUNC;
 
diff -urN busybox-1.36.1-ref/networking/udhcp/dhcp6.h busybox-1.36.1/networking/udhcp/dhcp6.h
--- busybox-1.36.1-ref/networking/udhcp/dhcp6.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.36.1/networking/udhcp/dhcp6.h	2023-05-19 23:01:27.857391888 +0300
@@ -0,0 +1,385 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 1998 and 1999 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef __DHCP6_H_DEFINED
+#define __DHCP6_H_DEFINED
+
+#include <sys/queue.h>
+
+/* Message type */
+#define DH6_SOLICIT		1
+#define DH6_ADVERTISE	2
+#define DH6_REQUEST		3
+#define DH6_CONFIRM		4
+#define DH6_RENEW		5
+#define DH6_REBIND		6
+#define DH6_REPLY		7
+#define DH6_RELEASE		8
+#define DH6_DECLINE		9
+#define DH6_RECONFIGURE	10
+#define DH6_INFORM_REQ	11
+#define DH6_RELAY_FORW	12
+#define DH6_RELAY_REPLY	13
+#define DH6__MSG__MAX	DH6_RELAY_REPLY
+
+/* Predefined addresses */
+#define DH6ADDR_ALLAGENT	"ff02::1:2"
+#define DH6ADDR_ALLSERVER	"ff05::1:3"
+#define DH6PORT_DOWNSTREAM	546
+#define DH6PORT_UPSTREAM	547
+
+/* Protocol constants */
+
+#define SOL_MAX_DELAY	1000	/* Solicit max delay, msec */
+
+#define DHCP6_DURATION_INFINITE 0xffffffff
+#define DHCP6_DURATION_MIN      30	/* 30 sec */
+
+#define DHCP6_RELAY_MULTICAST_HOPS  32
+#define DHCP6_RELAY_HOP_COUNT_LIMIT 32
+
+#define DHCP6_IRT_DEFAULT	86400	/* 1 day */
+#define DHCP6_IRT_MINIMUM	600
+
+struct dhcp6_vbuf {		/* generic variable length buffer */
+	int dv_len;
+	caddr_t dv_buf;
+};
+
+/* option information */
+struct dhcp6_ia {		/* identity association */
+	uint32_t iaid;
+	uint32_t t1;
+	uint32_t t2;
+};
+
+struct dhcp6_prefix {		/* IA_PD */
+	uint32_t pltime;
+	uint32_t vltime;
+	struct in6_addr addr;
+	int plen;
+};
+
+struct dhcp6_statefuladdr {	/* IA_NA */
+	uint32_t pltime;
+	uint32_t vltime;
+	struct in6_addr addr;
+};
+
+/* Internal data structure */
+typedef enum {
+	DHCP6_LISTVAL_NUM = 1, DHCP6_LISTVAL_NUM16, DHCP6_LISTVAL_NUM8,
+	DHCP6_LISTVAL_IA,
+	DHCP6_LISTVAL_ADDR6,
+	DHCP6_LISTVAL_PREFIX6,
+	DHCP6_LISTVAL_STATEFULADDR6,
+	DHCP6_LISTVAL_VBUF
+} dhcp6_listval_type_t;
+
+TAILQ_HEAD(dhcp6_list, dhcp6_listval);
+struct dhcp6_listval {
+	TAILQ_ENTRY(dhcp6_listval) link;
+
+	int dh6optype;					/* DHCPv6 option number (See D6_OPT_ ) */
+	dhcp6_listval_type_t lvtype;
+
+	union {
+		int32_t  uv_num;
+		uint16_t uv_num16;
+		uint8_t  uv_num8;
+		struct in6_addr uv_addr6;
+		struct dhcp6_prefix uv_prefix6;
+		struct dhcp6_statefuladdr uv_statefuladdr6;
+		struct dhcp6_ia uv_ia;
+		struct dhcp6_vbuf uv_vbuf;
+	} uv;
+
+	struct dhcp6_list sublist;
+};
+#define val_num           uv.uv_num
+#define val_num16         uv.uv_num16
+#define val_num8          uv.uv_num8
+#define val_addr6         uv.uv_addr6
+#define val_ia            uv.uv_ia
+#define val_prefix6       uv.uv_prefix6
+#define val_statefuladdr6 uv.uv_statefuladdr6
+#define val_vbuf          uv.uv_vbuf
+
+struct dhcp6_optinfo {
+	struct dhcp6_vbuf clientID;		/* DUID */
+	struct dhcp6_vbuf serverID;		/* DUID */
+
+	int rapidcommit;				/* bool */
+	int pref;						/* server preference */
+	int32_t elapsed_time;			/* elapsed time (from client to server only) */
+	int64_t refreshtime;			/* info refresh time for stateless options */
+
+	struct dhcp6_list ia_list;		/* list of IA_PD/IA_NA */
+	struct dhcp6_list reqopt_list;	/* options in option request */
+	struct dhcp6_list stcode_list;	/* status code */
+	struct dhcp6_list ad_list;		/* SIP/DNS/NTP/NIS/NIS+/BCMS servers/domain list */
+
+	struct dhcp6_vbuf relay_msg;	/* relay message */
+#define relaymsg_len relay_msg.dv_len
+#define relaymsg_msg relay_msg.dv_buf
+
+	struct dhcp6_vbuf ifidopt;		/* Interface-id */
+#define ifidopt_len ifidopt.dv_len
+#define ifidopt_id  ifidopt.dv_buf
+
+	uint16_t authflags;
+#define DHCP6OPT_AUTHFLAG_NOINFO	0x1
+	int authproto;
+	int authalgorithm;
+	int authrdm;
+	/* the followings are effective only when NOINFO is unset */
+	uint64_t authrd;
+	union {
+		struct {
+			uint32_t keyid;
+			struct dhcp6_vbuf realm;
+			int offset;			/* offset to the HMAC field */
+		} aiu_delayed;
+		struct {
+			int type;
+			int offset;			/* offset to the HMAC field */
+			char val[16];		/* key value */
+		} aiu_reconfig;
+	} authinfo;
+#define delayedauth_keyid    authinfo.aiu_delayed.keyid
+#define delayedauth_realm    authinfo.aiu_delayed.realm
+#define delayedauth_realmlen authinfo.aiu_delayed.realm.dv_len
+#define delayedauth_realmval authinfo.aiu_delayed.realm.dv_buf
+#define delayedauth_offset   authinfo.aiu_delayed.offset
+#define reconfigauth_type    authinfo.aiu_reconfig.type
+#define reconfigauth_offset  authinfo.aiu_reconfig.offset
+#define reconfigauth_val     authinfo.aiu_reconfig.val
+};
+
+/* DHCP6 base packet format */
+struct dhcp6 {
+	union {
+		uint8_t m;
+		uint32_t x;
+	} dh6_msgtypexid;
+	/* options follow */
+} __attribute__ ((__packed__));
+#define dh6_msgtype	dh6_msgtypexid.m
+#define dh6_xid		dh6_msgtypexid.x
+#define DH6_XIDMASK	0x00ffffff
+
+/* DHCPv6 relay messages */
+struct dhcp6_relay {
+	uint8_t dh6relay_msgtype;
+	uint8_t dh6relay_hcnt;
+	struct in6_addr dh6relay_linkaddr; /* XXX: badly aligned */
+	struct in6_addr dh6relay_peeraddr; /* ditto */
+	/* options follow */
+} __attribute__ ((__packed__));
+
+/* options */
+#define D6_OPT_CLIENTID				1			/* RFC3315 */
+#define D6_OPT_SERVERID				2			/* RFC3315 */
+#define D6_OPT_IA_NA				3			/* RFC3315 */
+#define D6_OPT_IA_TA				4			/* RFC3315 */
+#define D6_OPT_IAADDR				5			/* RFC3315 */
+#define D6_OPT_ORO					6			/* RFC3315 */
+#define D6_OPT_PREFERENCE			7			/* RFC3315 */
+#  define D6_OPT_PREF_MAX               255
+#define D6_OPT_ELAPSED_TIME			8			/* RFC3315 */
+#define D6_OPT_RELAY_MSG			9			/* RFC3315 */
+/* #define D6_OPT_10				10: deprecated */
+#define D6_OPT_AUTH					11			/* RFC3315 */
+#  define D6_OPT_AUTH_PROTO_DELAYED     2
+#  define D6_OPT_AUTH_RRECONFIGURE      3
+#  define D6_OPT_AUTH_ALG_HMACMD5       1
+#define D6_OPT_UNICAST				12			/* RFC3315 */
+#define D6_OPT_STATUS_CODE			13			/* RFC3315 */
+#  define D6_OPT_STCODE_SUCCESS         0
+#  define D6_OPT_STCODE_UNSPECFAIL      1
+#  define D6_OPT_STCODE_NOADDRSAVAIL    2
+#  define D6_OPT_STCODE_NOBINDING       3
+#  define D6_OPT_STCODE_NOTONLINK       4
+#  define D6_OPT_STCODE_USEMULTICAST    5
+#  define D6_OPT_STCODE_NOPREFIXAVAIL   6
+#  define D6_OPT_STCODE__MAX            D6_OPT_STCODE_NOPREFIXAVAIL
+
+#define D6_OPT_RAPID_COMMIT			14			/* RFC3315 */
+#define D6_OPT_USER_CLASS			15			/* RFC3315 */
+#define D6_OPT_VENDOR_CLASS			16			/* RFC3315 */
+#define D6_OPT_VENDOR_OPTS			17			/* RFC3315 */
+#define D6_OPT_INTERFACE_ID			18			/* RFC3315 */
+#define D6_OPT_RECONF_MSG			19			/* RFC3315 */
+#define D6_OPT_RECONF_ACCEPT		20			/* RFC3315 */
+
+#define D6_OPT_SIP_SERVER_D			21			/* RFC3319 */
+#define D6_OPT_SIP_SERVER_A			22			/* RFC3319 */
+#define D6_OPT_DNS					23			/* RFC3646 */
+#define D6_OPT_DNSNAME				24			/* RFC3646 */
+#define D6_OPT_IA_PD				25			/* RFC3633 */
+#define D6_OPT_IA_PD_PREFIX			26			/* RFC3633 */
+#define D6_OPT_NIS_SERVERS			27			/* RFC3898 */
+#define D6_OPT_NISP_SERVERS			28			/* RFC3898 */
+#define D6_OPT_NIS_DOMAIN			29			/* RFC3898 */
+#define D6_OPT_NISP_DOMAIN			30			/* RFC3898 */
+#define D6_OPT_SNTP_SERVERS			31			/* RFC4075 */
+#define D6_OPT_REFRESHTIME			32			/* RFC4242 */
+#define D6_OPT_BCMCS_SERVER_D		33			/* RFC4280 */
+#define D6_OPT_BCMCS_SERVER_A		34			/* RFC4280 */
+/* #define D6_OPT_35				35: unassigned */
+#define D6_OPT_GEOCONF_CIVIC		36			/* RFC4776 */
+#define D6_OPT_REMOTE_ID			37			/* RFC4649 */
+#define D6_OPT_SUBSCRIBER_ID		38			/* RFC4580 */
+#define D6_OPT_CLIENT_FQDN			39			/* RFC4704 */
+#define D6_OPT_PANA_AGENT			40			/* RFC5192 */
+#define D6_OPT_NEW_POSIX_TIMEZONE	41			/* RFC4833 */
+#define D6_OPT_NEW_TZDB_TIMEZONE	42			/* RFC4833 */
+#define D6_OPT_ERO					43			/* RFC4994 */
+#define D6_OPT_LQ_QUERY				44			/* RFC5007 */
+#define D6_OPT_CLIENT_DATA			45			/* RFC5007 */
+#define D6_OPT_CLT_TIME				46			/* RFC5007 */
+#define D6_OPT_LQ_RELAY_DATA		47			/* RFC5007 */
+#define D6_OPT_LQ_CLIENT_LINK		48			/* RFC5007 */
+#define D6_OPT_MIP6_HNINF			49			/* RFC-ietf-mip6-hiopt-17 */
+#define D6_OPT_MIP6_RELAY			50			/* RFC-ietf-mip6-hiopt-17 */
+#define D6_OPT_V6_LOST				51			/* RFC5223 */
+#define D6_OPT_CAPWAP_AC_V6			52			/* RFC5417 */
+#define D6_OPT_RELAY_ID				53			/* RFC5460 */
+#define D6_OPT_IPv6_Address_MoS		54			/* RFC5678 */
+#define D6_OPT_IPv6_FQDN_MoS		55			/* RFC5678 */
+#define D6_OPT_NTP_SERVER			56			/* RFC5908 */
+#define D6_OPT_V6_ACCESS_DOMAIN		57			/* RFC5986 */
+#define D6_OPT_SIP_UA_CS_LIST		58			/* RFC6011 */
+#define D6_OPT_BOOTFILE_URL			59			/* RFC5970 */
+#define D6_OPT_BOOTFILE_PARAM		60			/* RFC5970 */
+#define D6_OPT_CLIENT_ARCH_TYPE		61			/* RFC5970 */
+#define D6_OPT_NII					62			/* RFC5970 */
+#define D6_OPT__MAX					D6_OPT_NII
+
+/* The followings are KAME specific. */
+
+/* DUID type 1 (DUID-LLT) */
+struct dhcp6opt_duid_type1 {
+	uint16_t type;
+	uint16_t hwtype;
+	uint32_t time;
+	/* link-layer address follows */
+} __attribute__ ((__packed__));
+
+/* DUID type 2 (DUID-EN) */
+struct dhcp6opt_duid_type2 {
+	uint16_t type;
+	uint32_t enterprise_number;
+	/* identifier follows */
+} __attribute__ ((__packed__));
+
+/* DUID type 3 (DUID-LL) */
+struct dhcp6opt_duid_type3 {
+	uint16_t type;
+	uint16_t hwtype;
+	/* link-layer address follows */
+} __attribute__ ((__packed__));
+
+union dhcp6opt_duid_type {
+	uint16_t type;
+	struct dhcp6opt_duid_type1	d1;
+	struct dhcp6opt_duid_type2	d2;
+	struct dhcp6opt_duid_type3	d3;
+};
+
+struct dhcp6opt {
+	uint16_t dh6opt_type;
+	uint16_t dh6opt_len;
+	/* type-dependent data follows */
+} __attribute__ ((__packed__));
+
+#define __D6_OPT_COMMON(opt_prefix) \
+    struct dhcp6opt opt_prefix##opt
+
+/* Status Code */
+struct dhcp6opt_stcode {
+	__D6_OPT_COMMON (stcode_);
+	uint16_t dh6_stcode;
+} __attribute__ ((__packed__));
+
+/*
+ * General format of Identity Association.
+ * This format applies to Prefix Delegation (IA_PD) and Non-temporary Addresses
+ * (IA_NA)
+ */
+struct dhcp6opt_ia {
+	__D6_OPT_COMMON (ia_);
+	uint32_t dh6_iaid;
+	uint32_t dh6_t1;
+	uint32_t dh6_t2;
+	/* sub options follow */
+} __attribute__ ((__packed__));
+
+/* IA Addr */
+struct dhcp6opt_ia_addr {
+	__D6_OPT_COMMON (ia_addr_);
+	struct in6_addr dh6_addr;
+	uint32_t dh6_preferred_time;
+	uint32_t dh6_valid_time;
+} __attribute__ ((__packed__));
+
+/* IA_PD Prefix */
+struct dhcp6opt_ia_pd_prefix {
+	__D6_OPT_COMMON (iapd_prefix_);
+	uint32_t dh6_preferred_time;
+	uint32_t dh6_valid_time;
+	uint8_t dh6_prefix_len;
+	struct in6_addr dh6_prefix_addr;
+} __attribute__ ((__packed__));
+
+/* Authentication */
+struct dhcp6opt_auth {
+	__D6_OPT_COMMON (auth_);
+	uint8_t dh6_proto;
+	uint8_t dh6_alg;
+	uint8_t dh6_rdm;
+	uint8_t dh6_rdinfo[8];
+	/* authentication information follows */
+} __attribute__ ((__packed__));
+#undef __D6_OPT_COMMON
+
+
+enum {
+	DHCP6_AUTHPROTO_DELAYED  = 2,
+	DHCP6_AUTHPROTO_RECONFIG = 3
+};
+enum {
+	DHCP6_AUTHALG_HMACMD5 = 1
+};
+enum {
+	DHCP6_AUTHRDM_MONOCOUNTER = 0
+};
+
+#endif /* __DHCP6_H_DEFINED */
diff -urN busybox-1.36.1-ref/networking/udhcp/dhcp6c.c busybox-1.36.1/networking/udhcp/dhcp6c.c
--- busybox-1.36.1-ref/networking/udhcp/dhcp6c.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.36.1/networking/udhcp/dhcp6c.c	2023-05-19 23:01:27.857391888 +0300
@@ -0,0 +1,1370 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * DHCPv6 client
+ *
+ * Copyright (C) 1998 and 1999 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Original code taken from wide-dhcpv6-20080615 and converted into
+ * a busybox applet by Leonid Lisovskiy <lly@sf.net>
+ */
+//config:config DHCP6C
+//config:	bool "DHCPv6 client daemon (dhcp6c)"
+//config:	default n
+//config:	depends on FEATURE_IPV6
+//config:	help
+//config:	  dhcp6c is a DHCPv6 client geared primarily toward embedded systems,
+//config:	  while striving to be fully functional and RFC compliant.
+
+//config:config FEATURE_DHCP6_AUTH
+//config:	bool "Support DHCPv6 messages authentication"
+//config:	default n
+//config:	depends on DHCP6C
+//config:	help
+//config:	  If selected, client will support DHCPv6 messages authentication,
+//config:	  currently HMAC-MD5 only.
+
+//applet:IF_DHCP6C(APPLET(dhcp6c, BB_DIR_SBIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_DHCP6C) += dhcp6c_common.o common.o
+//kbuild:lib-$(CONFIG_DHCP6C) += dhcp6c.o dhcp6c_config.o dhcp6c_script.o dhcp6c_ia.o dhcp6c_socket.o
+//kbuild:lib-$(CONFIG_FEATURE_DHCP6_AUTH) += dhcp6c_auth.o
+
+#include <net/if.h>
+#include <syslog.h>
+
+/* Override ENABLE_FEATURE_PIDFILE */
+#define WANT_PIDFILE 1
+#include "dhcp6c.h"
+#include "dhcp6c_auth.h"
+
+#define DHCP6C_CONF     "/etc/dhcp6c.conf"
+#define DHCP6C_PIDFILE  "/var/run/dhcp6c.pid"
+#define DUID_FILE       "/tmp/dhcp6c_duid"
+
+struct globals {
+	len_and_sockaddr *sa6_allagent;
+
+	const char *pid_file;
+
+	int csock;	/* inbound/outbound udp port */
+
+	char rbuf[BUFSIZ], sbuf[BUFSIZ];
+
+	struct dhcp6_vbuf client_duid;
+	int duid_type;
+} FIX_ALIASING;
+
+void BUG_dhcp6c_globals_too_big(void);
+#define G (*ptr_to_globals)
+#define csock		(G.csock        )
+#define INIT_G() do { \
+	if (sizeof(struct client6_config_t) > COMMON_BUFSIZE / 2) \
+		BUG_dhcp6c_globals_too_big(); \
+	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
+	G.pid_file = DHCP6C_PIDFILE; \
+	G.duid_type = 1; \
+} while (0)
+
+
+/* dhcp6c_ia.c */
+extern void destruct_iadata(struct dhcp6_eventdata *evd);
+
+static void if6init(struct dhcp6_if *ifp, const char *ifname);
+static void dhcp6_remove_evdata(struct dhcp6_event *);
+static void client6_startall(int isrestart);
+static void client6_mainloop(void);
+static void free_resources(int force);
+static void check_exit(int force);
+static struct dhcp6_serverinfo *find_server(struct dhcp6_event *,
+						 struct dhcp6_vbuf *);
+static struct dhcp6_serverinfo *select_server(struct dhcp6_event *);
+static void client6_recv(void);
+static int client6_recvadvert(const struct dhcp6_if *, struct dhcp6_event *,
+				   struct dhcp6_optinfo *);
+static int client6_recvreply(struct dhcp6_if *, struct dhcp6_event *,
+				  struct dhcp6_optinfo *);
+static struct dhcp6_event *find_event_withid(unsigned int ifid, uint32_t xid);
+static int construct_confdata(const struct dhcp6_if *, struct dhcp6_event *);
+static int construct_reqdata(const struct dhcp6_if *, struct dhcp6_optinfo *,
+    struct dhcp6_event *);
+static struct dhcp6_timer *client6_expire_refreshtime(void *);
+static struct dhcp6_timer *client6_timo(void *arg);
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int process_auth(struct authparam *, struct dhcp6 *dh6, ssize_t,
+    struct dhcp6_optinfo *);
+static int set_auth(struct dhcp6_event *, struct dhcp6_optinfo *);
+#endif
+
+enum {
+        OPT_FOREGROUND = 1 << 0,
+        OPT_i = 1 << 1,
+        OPT_c = 1 << 2,
+        OPT_D = 1 << 3,
+        OPT_p = 1 << 4,
+        OPT_VERBOSE = 1 << 5,
+};
+
+//usage:#define dhcp6c_trivial_usage
+//usage:       "[-vfi] [-c FILE] [-D LL|LLT] [-p FILE] interface"
+//usage:#define dhcp6c_full_usage "\n"
+//usage:      "\n	-v         Print debugging messages(may be repeated)"
+//usage:      "\n	-f         Foreground mode"
+//usage:      "\n	-i         Info-req(information-only) mode"
+//usage:      "\n	-c FILE    Use FILE as the configuration file"
+//usage:      "\n	-D LL|LLT  Use LL or LLT to override default(LLT) DUID type generation"
+//usage:      "\n	-p FILE    Use FILE to dump the process ID of dhcp6c"
+
+int dhcp6c_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int dhcp6c_main(int argc UNUSED_PARAM, char **argv)
+{
+	int opt;
+	const char *str_D;
+
+	INIT_G();
+	client6_config.conffile = DHCP6C_CONF;
+
+	srandom(getpid());
+
+	opt = getopt32(argv, "^fic:D:p:v" "\0" "=1" IF_UDHCP_VERBOSE("vv"),
+			&client6_config.conffile, &str_D, &G.pid_file
+			IF_UDHCP_VERBOSE(, &dhcp_verbose)
+			);
+	if (opt & OPT_D) {
+		if (strcasecmp(str_D, "LL") == 0)
+			G.duid_type = 3;
+		else if (strcasecmp(str_D, "LLT") == 0)
+			G.duid_type = 1;
+	}
+
+	if (!(opt & OPT_FOREGROUND) && !(opt & OPT_i)) {
+		bb_daemonize_or_rexec(DAEMON_CLOSE_EXTRA_FDS, argv);
+		openlog(applet_name, LOG_PID, LOG_DAEMON);
+		logmode = LOGMODE_SYSLOG;
+	}
+
+	bb_signals(0 + (1 << SIGHUP) + (1 << SIGTERM) + (1 << SIGQUIT),
+		  record_signo);
+
+	if6init(&client6_config.dhcp6c_if, argv[optind]);
+
+	if (!(opt & OPT_i) && (read_config6(client6_config.conffile)) != 0) {
+		bb_error_msg_and_die("can't parse config");
+	}
+
+	bb_error_msg("started");
+	/* get our DUID */
+	if (get_duid(DUID_FILE, &G.client_duid, G.duid_type)) {
+		bb_error_msg_and_die("can't get a DUID");
+	}
+
+	G.sa6_allagent = xhost_and_af2sockaddr(DH6ADDR_ALLAGENT, DH6PORT_UPSTREAM, AF_INET6);
+
+	csock = sock6_init(NULL, xstr(DH6PORT_DOWNSTREAM));
+	setsockopt_bindtodevice(csock, client6_config.dhcp6c_if.ifname);
+	if (setsockopt_1(csock, IPPROTO_IPV6, IPV6_MULTICAST_LOOP) < 0) {
+		bb_perror_msg_and_die("setsockopt(IPV6_MULTICAST_LOOP)");
+	}
+
+	LIST_INIT(&client6_config.timer_head);
+	client6_config.tm_sentinel = ULLONG_MAX;
+	TAILQ_INIT(&client6_config.event_list);
+
+	/* dump current PID */
+	write_pidfile(G.pid_file);
+
+	client6_startall(0);
+	client6_mainloop();
+	return 0;
+}
+
+
+/*------------------------------------------------------------*/
+
+static void if6init(struct dhcp6_if *ifp, const char *ifname)
+{
+	ifp->ifid = if_nametoindex(ifname);
+	if (ifp->ifid == 0) {
+		bb_perror_msg_and_die("invalid interface(%s)", ifp->ifname);
+	}
+
+	ifp->ifname = xstrdup(ifname);
+
+	TAILQ_INIT(&ifp->reqopt_list);
+	TAILQ_INIT(&ifp->iaconf_list);
+#if ENABLE_FEATURE_DHCP6_AUTH
+	ifp->authproto = -1;
+	ifp->authalgorithm = -1;
+	ifp->authrdm = -1;
+#endif
+}
+
+struct dhcp6_event *dhcp6_create_event(const struct dhcp6_if *ifp, int state)
+{
+	struct dhcp6_event *ev;
+
+	ev = xzalloc(sizeof(*ev));
+	ev->ifp = ifp;
+	ev->state = state;
+	TAILQ_INIT(&ev->data_list);
+
+	TAILQ_INSERT_TAIL(&client6_config.event_list, ev, link);
+
+	ev->timer = dhcp6_timer_add(client6_timo, ev);
+
+	return ev;
+}
+
+void dhcp6_remove_event(struct dhcp6_event *ev)
+{
+	struct dhcp6_serverinfo *sp, *sp_next;
+
+	log1("removing an event on %s, state=%s",
+	    ev->ifp->ifname, dhcp6_event_statestr(ev));
+
+	if (ev->timer)
+		dhcp6_timer_remove(&ev->timer);
+
+	dhcp6_remove_evdata(ev);
+	dhcp6_vbuf_free(&ev->serverid);
+	TAILQ_REMOVE(&client6_config.event_list, ev, link);
+
+	sp = ev->servers;
+	while (sp) {
+		sp_next = sp->next;
+
+		log1("removing server (ID: %s)", duidstr(&sp->optinfo.serverID));
+		dhcp6_clear_options(&sp->optinfo);
+#if ENABLE_FEATURE_DHCP6_AUTH
+		free(sp->authparam);
+#endif
+		free(sp);
+		sp = sp_next;
+	}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	free(ev->authparam);
+#endif
+	free(ev);
+}
+
+static void dhcp6_remove_evdata(struct dhcp6_event *ev)
+{
+	struct dhcp6_eventdata *evd;
+
+	while ((evd = TAILQ_FIRST(&ev->data_list)) != NULL) {
+		TAILQ_REMOVE(&ev->data_list, evd, link);
+		destruct_iadata(evd);
+	}
+}
+
+int client6_start(struct dhcp6_if *ifp)
+{
+	struct dhcp6_event *ev;
+
+	/* make sure that the interface does not have a timer */
+	if (ifp->timer)
+		dhcp6_timer_remove(&ifp->timer);
+
+	/* create an event for the initial delay */
+	ev = dhcp6_create_event(ifp, DHCP6S_INIT);
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	ev->authparam = new_authparam(ifp->authproto,
+	    ifp->authalgorithm, ifp->authrdm);
+#endif
+
+	dhcp6_reset_timer(ev);
+
+	return 0;
+}
+
+static void client6_startall(int isrestart)
+{
+	struct dhcp6_if *ifp = &client6_config.dhcp6c_if;
+
+	if (isrestart) {
+		/* reload the configuration file */
+		if (read_config6(client6_config.conffile))
+			bb_error_msg_and_die("can't parse config");
+
+		ifp->ifid = if_nametoindex(ifp->ifname);
+		if (ifp->ifid == 0)
+			bb_error_msg_and_die("invalid interface(%s)", ifp->ifname);
+	}
+
+	if (client6_start(ifp)) {
+		exit(1); /* initialization failure.  we give up. */
+	}
+}
+
+static void free_resources(int force)
+{
+	struct dhcp6_event *ev, *ev_next;
+
+	/* release all IAs as well as send RELEASE message(s) */
+	release_all_ia(&client6_config.dhcp6c_if);
+
+	/*
+	 * Cancel all outstanding events for each interface except
+	 * ones being released.
+	 */
+	for (ev = TAILQ_FIRST(&client6_config.event_list); ev; ev = ev_next) {
+		ev_next = TAILQ_NEXT(ev, link);
+
+		if (!force && ev->state == DHCP6S_RELEASE)
+			continue; /* keep it for now */
+
+		dhcp6_remove_event(ev);
+	}
+}
+
+static void check_exit(int force)
+{
+	if (!force) {
+		if (!bb_got_signal)
+			return;
+
+		/*
+		 * Check if we have an outstanding event.  If we do, we cannot
+		 * exit for now.
+		 */
+		if (!TAILQ_EMPTY(&client6_config.event_list))
+			return;
+	}
+
+	/* We have no existing event.  Do exit. */
+	bb_error_msg("exiting");
+	free_resources(1);
+	if (ENABLE_FEATURE_CLEAN_UP) {
+		free(G.sa6_allagent);
+		dhcp6_vbuf_free(&G.client_duid);
+		clear_ifconf(1);
+	}
+	remove_pidfile(G.pid_file);
+
+	exit(0);
+}
+
+static void client6_mainloop(void)
+{
+	struct timeval *w;
+	int ret, maxsock;
+	fd_set r;
+
+	while (1) {
+		if (bb_got_signal) {
+			switch (bb_got_signal) {
+			case SIGQUIT:
+			case SIGTERM:
+				check_exit(1);
+				break;
+			case SIGHUP:
+				bb_error_msg("restarting");
+				bb_got_signal = 0;
+				free_resources(0);
+				client6_startall(1);
+				break;
+			}
+		}
+
+		w = dhcp6_timer_check();
+
+		FD_ZERO(&r);
+		FD_SET(csock, &r);
+		maxsock = csock;
+
+		ret = select(maxsock + 1, &r, NULL, NULL, w);
+
+		switch (ret) {
+		case -1:
+			if (errno != EINTR) {
+				bb_perror_msg_and_die("select");
+			}
+			continue;
+		case 0:	/* timeout */
+			break;	/* dhcp6_timer_check() will treat the case */
+		default:
+			break;
+		}
+		if (FD_ISSET(csock, &r))
+			client6_recv();
+	}
+}
+
+static struct dhcp6_timer *client6_expire_refreshtime(void *arg)
+{
+	struct dhcp6_if *ifp = (struct dhcp6_if *)arg;
+
+	log1("information refresh time on %s expired", ifp->ifname);
+
+	dhcp6_timer_remove(&ifp->timer);
+	client6_start(ifp);
+
+	return NULL;
+}
+
+static struct dhcp6_timer *client6_timo(void *arg)
+{
+	struct dhcp6_event *ev = (struct dhcp6_event *)arg;
+	const struct dhcp6_if *ifp;
+	int state = ev->state;
+
+	ifp = ev->ifp;
+	ev->timeouts++;
+
+	/*
+	 * Unless MRC is zero, the message exchange fails once the client has
+	 * transmitted the message MRC times.
+	 * [RFC3315 14.]
+	 */
+	if (ev->max_retrans_cnt && ev->timeouts >= ev->max_retrans_cnt) {
+		bb_error_msg("no responses were received");
+		dhcp6_remove_event(ev);
+
+		if (state == DHCP6S_RELEASE)
+			check_exit(0);
+
+		return NULL;
+	}
+
+	switch (ev->state) {
+	case DHCP6S_INIT:
+		ev->timeouts = 0; /* indicate to generate a new XID. */
+		if ((ifp->send_flags & DHCIFF_INFO_ONLY) || (option_mask32 & OPT_i)) {
+			ev->state = DHCP6S_INFOREQ;
+		} else {
+			ev->state = DHCP6S_SOLICIT;
+			if (construct_confdata(ifp, ev)) {
+				bb_error_msg_and_die("can't send solicit"); /* XXX */
+			}
+		}
+		dhcp6_set_timeoparam(ev); /* XXX */
+		/* fall through */
+	case DHCP6S_REQUEST:
+	case DHCP6S_RELEASE:
+	case DHCP6S_INFOREQ:
+		client6_send(ev);
+		break;
+	case DHCP6S_RENEW:
+	case DHCP6S_REBIND:
+		if (!TAILQ_EMPTY(&ev->data_list)) {
+			client6_send(ev);
+		} else {
+			bb_error_msg("all information to be updated was canceled");
+			dhcp6_remove_event(ev);
+			return NULL;
+		}
+		break;
+	case DHCP6S_SOLICIT:
+		if (ev->servers) {
+			/*
+			 * Send a Request to the best server.
+			 * Note that when we set Rapid-commit in Solicit,
+			 * but a direct Reply has been delayed (very much),
+			 * the transition to DHCP6S_REQUEST (and the change of
+			 * transaction ID) will invalidate the reply even if it
+			 * ever arrives.
+			 */
+			ev->current_server = select_server(ev);
+			if (ev->current_server == NULL) {
+				/* this should not happen! */
+				bb_error_msg_and_die("can't find a server");
+			}
+			dhcp6_vbuf_copy(&ev->serverid, &ev->current_server->optinfo.serverID);
+			ev->timeouts = 0;
+			ev->state = DHCP6S_REQUEST;
+			dhcp6_set_timeoparam(ev);
+#if ENABLE_FEATURE_DHCP6_AUTH
+			free(ev->authparam);
+			ev->authparam = ev->current_server->authparam;
+			ev->current_server->authparam = NULL;
+#endif
+			if (construct_reqdata(ifp, &ev->current_server->optinfo, ev)) {
+				bb_error_msg("can't construct request");
+				break;
+			}
+		}
+		client6_send(ev);
+		break;
+	}
+
+	dhcp6_reset_timer(ev);
+
+	return ev->timer;
+}
+
+static int construct_confdata(const struct dhcp6_if *ifp, struct dhcp6_event *ev)
+{
+	struct ia_conf *iac;
+	struct dhcp6_eventdata *evd = NULL;
+	struct dhcp6_list *ial = NULL;
+	struct dhcp6_ia iaparam;
+
+	TAILQ_FOREACH(iac, &ifp->iaconf_list, link) {
+		/* ignore IA config currently used */
+		if (!TAILQ_EMPTY(&iac->iadata))
+			continue;
+
+		memset(&iaparam, 0, sizeof(iaparam));
+		iaparam.iaid = iac->iaid;
+
+		switch (iac->type) {
+		case D6_OPT_IA_PD:
+		case D6_OPT_IA_NA:
+			ial = xmalloc(sizeof(*ial));
+			TAILQ_INIT(ial);
+
+			if (dhcp6_add_listval(ial, iac->type, DHCP6_LISTVAL_IA,
+			    &iaparam, &iac->prefix_list) == NULL) {
+				goto fail;
+			}
+			break;
+		default:
+			bb_error_msg_and_die("impossible IA type %d", iac->type);
+		}
+
+		evd = xzalloc(sizeof(*evd));
+		evd->type = iac->type;
+		evd->data = ial;
+		evd->event = ev;
+		TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
+	}
+
+	return 0;
+
+  fail:
+	free(evd);
+	free(ial);
+	dhcp6_remove_event(ev);	/* XXX */
+
+	return -1;
+}
+
+static int construct_reqdata(const struct dhcp6_if *ifp, struct dhcp6_optinfo *optinfo,
+		  struct dhcp6_event *ev)
+{
+	struct ia_conf *iac;
+	struct dhcp6_eventdata *evd = NULL;
+	struct dhcp6_list *ial = NULL;
+	struct dhcp6_ia iaparam;
+
+	/* discard previous event data */
+	dhcp6_remove_evdata(ev);
+
+	if (optinfo == NULL)
+		return 0;
+
+	TAILQ_FOREACH(iac, &ifp->iaconf_list, link) {
+		struct dhcp6_listval *lv;
+
+		/* ignore IA config currently used */
+		if (!TAILQ_EMPTY(&iac->iadata))
+			continue;
+
+		memset(&iaparam, 0, sizeof(iaparam));
+		iaparam.iaid = iac->iaid;
+
+		switch (iac->type) {
+		case D6_OPT_IA_PD:
+		case D6_OPT_IA_NA:
+			lv = dhcp6_find_listval(&optinfo->ia_list,
+			    iac->type, &iaparam, MATCHLIST_DH6OPTYPE);
+			if (lv == NULL)
+				continue;
+
+			ial = xmalloc(sizeof(*ial));
+			TAILQ_INIT(ial);
+
+			if (dhcp6_add_listval(ial, iac->type, DHCP6_LISTVAL_IA,
+			    &iaparam, &lv->sublist) == NULL) {
+				goto fail;
+			}
+			break;
+		default:
+			bb_error_msg_and_die("impossible IA type %d", iac->type);
+		}
+
+		evd = xzalloc(sizeof(*evd));
+		evd->type = iac->type;
+		evd->data = ial;
+		evd->event = ev;
+		TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
+	}
+
+	return 0;
+
+  fail:
+	free(evd);
+	free(ial);
+	dhcp6_remove_event(ev);	/* XXX */
+
+	return -1;
+}
+
+static struct dhcp6_serverinfo *select_server(struct dhcp6_event *ev)
+{
+	struct dhcp6_serverinfo *s = ev->servers;
+
+	/*
+	 * pick the best server according to RFC3315 Section 17.1.3.
+	 * XXX: we currently just choose the one that is active and has the
+	 * highest preference.
+	 */
+	while (s) {
+		if (s->active) {
+			log1("picked a server (ID: %s)", duidstr(&s->optinfo.serverID));
+			return s;
+		}
+		s = s->next;
+	}
+
+	return NULL;
+}
+
+static struct dhcp6_serverinfo *find_server(struct dhcp6_event *ev,
+					 struct dhcp6_vbuf *duid)
+{
+	struct dhcp6_serverinfo *s = ev->servers;
+
+	while (s) {
+		if (dhcp6_vbuf_cmp(&s->optinfo.serverID, duid) == 0)
+			return s;
+
+		s = s->next;
+	}
+
+	return NULL;
+}
+
+void client6_send(struct dhcp6_event *ev)
+{
+	const struct dhcp6_if *ifp = ev->ifp;
+	struct dhcp6 *dh6 = (struct dhcp6 *)G.sbuf;
+	struct sockaddr_in6 dst;
+	struct dhcp6_optinfo optinfo;
+	ssize_t optlen, len;
+	struct dhcp6_eventdata *evd;
+
+	len = sizeof(struct dhcp6);
+	memset(dh6, 0, len);
+	dh6->dh6_msgtype = ev->state;
+
+	if (ev->timeouts == 0) {
+		/*
+		 * A client SHOULD generate a random number that cannot easily
+		 * be guessed or predicted to use as the transaction ID for
+		 * each new message it sends.
+		 *
+		 * A client MUST leave the transaction-ID unchanged in
+		 * retransmissions of a message. [RFC3315 15.1]
+		 */
+		ev->xid = random() & DH6_XIDMASK;
+		log1("a new XID (%x) is generated",
+		    ev->xid);
+	}
+	dh6->dh6_xid &= ~ntohl(DH6_XIDMASK);
+	dh6->dh6_xid |= htonl(ev->xid);
+
+	/*
+	 * construct options
+	 */
+	dhcp6_init_options(&optinfo);
+
+	/* server ID */
+	switch (ev->state) {
+	case DHCP6S_REQUEST:
+	case DHCP6S_RENEW:
+	case DHCP6S_RELEASE:
+		dhcp6_vbuf_copy(&optinfo.serverID, &ev->serverid);
+		break;
+	}
+
+	/* client ID */
+	dhcp6_vbuf_copy(&optinfo.clientID, &G.client_duid);
+
+	/* rapid commit (in Solicit only) */
+	if (ev->state == DHCP6S_SOLICIT && (ifp->send_flags & DHCIFF_RAPID_COMMIT)) {
+		optinfo.rapidcommit = 1;
+	}
+
+	/* elapsed time */
+	if (ev->timeouts == 0) {
+		ev->t_start = monotonic_ms();
+		optinfo.elapsed_time = 0;
+	} else {
+		long long t_diff;
+
+		t_diff = (monotonic_ms() - ev->t_start) / 10LL;
+		/*
+		 * The client uses the value 0xffff to represent any elapsed
+		 * time values greater than the largest time value that can be
+		 * represented in the Elapsed Time option (hundredths of a second).
+		 * [RFC3315 22.9.]
+		 */
+		if (t_diff > MAX_ELAPSED_TIME) {
+			/*
+			 * Perhaps we are nervous too much, but without this
+			 * additional check, we would see an overflow in 248
+			 * days (of no responses).
+			 */
+			t_diff = MAX_ELAPSED_TIME;
+		}
+		optinfo.elapsed_time = (int32_t )t_diff;
+	}
+
+	/* option request options */
+	if (ev->state != DHCP6S_RELEASE &&
+	    dhcp6_copy_list(&optinfo.reqopt_list, &ifp->reqopt_list)) {
+		bb_error_msg("can't copy requested options");
+		goto end;
+	}
+
+	/* configuration information specified as event data */
+	evd = TAILQ_FIRST(&ev->data_list);
+	while (evd) {
+		if (dhcp6_copy_list(&optinfo.ia_list, (struct dhcp6_list *)evd->data)) {
+			bb_error_msg("can't add IA");
+			goto end;
+		}
+		evd = TAILQ_NEXT(evd, link);
+	}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	/* authentication information */
+	if (set_auth(ev, &optinfo)) {
+		goto end;
+	}
+#endif
+
+	/* set options in the message */
+	optlen = dhcp6_set_options(dh6->dh6_msgtype,
+	    (struct dhcp6opt *)(dh6 + 1),
+	    (struct dhcp6opt *)(G.sbuf + sizeof(G.sbuf)), &optinfo);
+	if (optlen < 0) {
+		bb_error_msg("can't construct options");
+		goto end;
+	}
+	len += optlen;
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	/* calculate MAC if necessary, and put it to the message */
+	if (ev->authparam != NULL) {
+		switch (ev->authparam->authproto) {
+		case DHCP6_AUTHPROTO_DELAYED:
+			if (ev->authparam->key == NULL)
+				break;
+
+			if (dhcp6_calc_mac((char *)dh6, len,
+					optinfo.authproto, optinfo.authalgorithm,
+					optinfo.delayedauth_offset + sizeof(*dh6),
+					ev->authparam->key)) {
+				bb_error_msg("can't calculate MAC");
+				goto end;
+			}
+			break;
+		default:
+			break;	/* do nothing */
+		}
+	}
+#endif
+
+	/*
+	 * Unless otherwise specified in this document or in a document that
+	 * describes how IPv6 is carried over a specific type of link (for link
+	 * types that do not support multicast), a client sends DHCP messages
+	 * to the All_DHCP_Relay_Agents_and_Servers.
+	 * [RFC3315 Section 13.]
+	 */
+	dst = G.sa6_allagent->u.sin6;
+	dst.sin6_scope_id = ifp->ifid;
+
+	if (sendto(csock, G.sbuf, len, 0, (struct sockaddr *)&dst,
+			sizeof(dst)) == -1) {
+		bb_perror_msg("sendto");
+		goto end;
+	}
+
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+	{
+		char *a = xmalloc_sockaddr2dotted_noport((struct sockaddr *)&dst);
+		log1("send %s to %s", dhcp6msgstr(dh6->dh6_msgtype), a);
+		free(a);
+	}
+#endif
+
+ end:
+	dhcp6_clear_options(&optinfo);
+}
+
+static void client6_recv(void)
+{
+	struct sockaddr from;
+	struct sockaddr_in6 to;
+	struct dhcp6_if *ifp = &client6_config.dhcp6c_if;
+	struct dhcp6_optinfo optinfo;
+	ssize_t len;
+	const struct dhcp6 *dh6 = (struct dhcp6 *)G.rbuf;
+	struct dhcp6_event *ev;
+	char *a;
+
+	len = recv_from_to(csock, G.rbuf, sizeof(G.rbuf), 0,
+			&from, (struct sockaddr *)&to, sizeof(struct sockaddr_in6));
+	if (len < sizeof(struct dhcp6)) {
+		if (len >= 0)
+			bb_error_msg("short packet (%d bytes)", (int )len);
+		return;
+	}
+
+	if (ifp->ifid != to.sin6_scope_id) {
+		char ifname[IFNAMSIZ];
+
+		bb_error_msg("unexpected interface (%s)",
+				if_indextoname(to.sin6_scope_id, ifname));
+		return;
+	}
+
+	a = xmalloc_sockaddr2dotted_noport(&from);
+	log1("receive %s from %s on %s", dhcp6msgstr(dh6->dh6_msgtype),
+		a, ifp->ifname);
+
+	if (dh6->dh6_msgtype != DH6_ADVERTISE && dh6->dh6_msgtype != DH6_REPLY) {
+		bb_error_msg("received an unexpected message (%s) from %s",
+			dhcp6msgstr(dh6->dh6_msgtype), a);
+		free(a);
+		return;
+	}
+
+	/* get options */
+	dhcp6_init_options(&optinfo);
+	if (dhcp6_get_options((struct dhcp6opt *)(dh6 + 1),
+	    (struct dhcp6opt *)((char *)dh6 + len), &optinfo) < 0) {
+		bb_error_msg("can't parse options");
+		goto fail;
+	}
+
+	/* find the corresponding event based on the received xid */
+	ev = find_event_withid(ifp->ifid, ntohl(dh6->dh6_xid) & DH6_XIDMASK);
+	if (ev == NULL) {
+		bb_error_msg("XID mismatch");
+		goto fail;
+	}
+
+	/* packet validation based on Section 15.3 of RFC3315. */
+	if (optinfo.serverID.dv_len == 0) {
+		bb_error_msg("no server ID");
+		goto fail;
+	}
+
+	if (optinfo.clientID.dv_len == 0) {
+		bb_error_msg("no client ID");
+		goto fail;
+	}
+	/*
+	 * DUID in the Client ID option (which must be contained for our
+	 * client implementation) must match ours.
+	 */
+	if (dhcp6_vbuf_cmp(&optinfo.clientID, &G.client_duid)) {
+		bb_error_msg("client DUID mismatch");
+		goto fail;
+	}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	/* validate authentication */
+	if (process_auth(ev->authparam, dh6, len, &optinfo)) {
+		bb_error_msg("auth fail");
+		goto fail;
+	}
+#endif
+
+	switch (dh6->dh6_msgtype) {
+	case DH6_ADVERTISE:
+		client6_recvadvert(ifp, ev, &optinfo);
+		break;
+	case DH6_REPLY:
+		client6_recvreply(ifp, ev, &optinfo);
+		break;
+	}
+
+fail:
+	dhcp6_clear_options(&optinfo);
+	free(a);
+	return;
+}
+
+static int client6_recvadvert(const struct dhcp6_if *ifp, struct dhcp6_event *ev,
+				struct dhcp6_optinfo *optinfo)
+{
+	struct dhcp6_serverinfo *newserver, **sp;
+	struct dhcp6_eventdata *evd;
+	int have_ia = -1;
+
+	/*
+	 * The requesting router MUST ignore any Advertise message that
+	 * includes a Status Code option containing the value NoPrefixAvail
+	 * [RFC3633 Section 11.1].
+	 * Likewise, the client MUST ignore any Advertise message that includes
+	 * a Status Code option containing the value NoAddrsAvail.
+	 * [RFC3315 Section 17.1.3].
+	 * We only apply this when we are going to request an address or
+	 * a prefix.
+	 */
+	TAILQ_FOREACH(evd, &ev->data_list, link) {
+		struct dhcp6_listval *lv, *slv;
+		dhcp6_listval_type_t lvtype;
+		uint16_t stcode;
+
+		switch (evd->type) {
+		case D6_OPT_IA_PD:
+			stcode = D6_OPT_STCODE_NOPREFIXAVAIL;
+			lvtype = DHCP6_LISTVAL_PREFIX6;
+			break;
+		case D6_OPT_IA_NA:
+			stcode = D6_OPT_STCODE_NOADDRSAVAIL;
+			lvtype = DHCP6_LISTVAL_STATEFULADDR6;
+			break;
+		default:
+			continue;
+		}
+		if (dhcp6_find_listval(&optinfo->stcode_list,
+		    DHCP6_LISTVAL_NUM16, &stcode, 0)) {
+			bb_error_msg("advertise contains %s status", dhcp6stcodestr(stcode));
+			return -1;
+		}
+
+		if (have_ia > 0 || TAILQ_EMPTY((struct dhcp6_list *)evd->data))
+			continue;
+		have_ia = 0;
+		TAILQ_FOREACH(lv, (struct dhcp6_list *)evd->data, link) {
+			slv = dhcp6_find_listval(&optinfo->ia_list,
+			    evd->type, &lv->val_ia, MATCHLIST_DH6OPTYPE);
+			if (slv == NULL)
+				continue;
+			TAILQ_FOREACH(slv, &slv->sublist, link) {
+				if (slv->lvtype == lvtype) {
+					have_ia = 1;
+					break;
+				}
+			}
+		}
+	}
+
+	/* Ignore message with none of requested addresses and/or
+	 * a prefixes as if NoAddrsAvail/NoPrefixAvail Status Code
+	 * was included.
+	 */
+	if (have_ia == 0) {
+		bb_error_msg("advertise contains no address/prefix");
+		return -1;
+	}
+
+	if (ev->state != DHCP6S_SOLICIT ||
+	    (ifp->send_flags & DHCIFF_RAPID_COMMIT) || (option_mask32 & OPT_i)) {
+		/*
+		 * We expected a reply message, but do actually receive an
+		 * Advertise message.  The server should be configured not to
+		 * allow the Rapid Commit option.
+		 * We process the message as if we expected the Advertise.
+		 * [RFC3315 Section 17.1.4]
+		 */
+		bb_error_msg("unexpected advertise");
+		/* proceed anyway */
+	}
+
+	/* ignore the server if it is known */
+	if (find_server(ev, &optinfo->serverID)) {
+		bb_error_msg("duplicated server (ID: %s)", duidstr(&optinfo->serverID));
+		return -1;
+	}
+
+	/* keep the server */
+	newserver = xzalloc(sizeof(*newserver));
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	/* remember authentication parameters */
+	newserver->authparam = ev->authparam;
+
+	/* allocate new authentication parameter for the soliciting event */
+	ev->authparam = new_authparam(ev->authparam->authproto,
+		ev->authparam->authalgorithm, ev->authparam->authrdm);
+#endif
+
+	/* copy options */
+	dhcp6_init_options(&newserver->optinfo);
+	dhcp6_copy_options(&newserver->optinfo, optinfo);
+	if (optinfo->pref != -1)
+		newserver->pref = optinfo->pref;
+	newserver->active = 1;
+	for (sp = &ev->servers; *sp; sp = &(*sp)->next) {
+		if ((*sp)->pref != D6_OPT_PREF_MAX && (*sp)->pref < newserver->pref) {
+			break;
+		}
+	}
+	newserver->next = *sp;
+	*sp = newserver;
+
+	if (newserver->pref == D6_OPT_PREF_MAX) {
+		/*
+		 * If the client receives an Advertise message that includes a
+		 * Preference option with a preference value of 255, the client
+		 * immediately begins a client-initiated message exchange.
+		 * [RFC3315 Section 17.1.2]
+		 */
+		ev->current_server = newserver;
+		dhcp6_vbuf_copy(&ev->serverid, &ev->current_server->optinfo.serverID);
+		if (construct_reqdata(ifp, &ev->current_server->optinfo, ev)) {
+			bb_error_msg("can't construct request");
+			return -1; /* XXX */
+		}
+
+		ev->timeouts = 0;
+		ev->state = DHCP6S_REQUEST;
+#if ENABLE_FEATURE_DHCP6_AUTH
+		free(ev->authparam);
+		ev->authparam = newserver->authparam;
+		newserver->authparam = NULL;
+#endif
+		client6_send(ev);
+
+		dhcp6_set_timeoparam(ev);
+		dhcp6_reset_timer(ev);
+	} else if (ev->servers->next == NULL) {
+		unsigned long long elapsed, timo;
+
+		/*
+		 * If this is the first advertise, adjust the timer so that
+		 * the client can collect other servers until IRT elapses.
+		 */
+		elapsed = ev->retrans - dhcp6_timer_rest(ev->timer);
+		if (elapsed <= ev->init_retrans)
+			timo = ev->init_retrans - elapsed;
+		else
+			timo = 0;
+
+		log1("reset timer for %s to %d.%03d",
+		    ifp->ifname, (int )(timo/1000ULL), (int )(timo%1000ULL));
+
+		dhcp6_timer_set(timo, ev->timer);
+	}
+
+	return 0;
+}
+
+static int client6_recvreply(struct dhcp6_if *ifp, struct dhcp6_event *ev,
+				struct dhcp6_optinfo *optinfo)
+{
+	struct dhcp6_listval *lv;
+	int state;
+
+	state = ev->state;
+	if (state != DHCP6S_INFOREQ &&
+	    state != DHCP6S_REQUEST &&
+	    state != DHCP6S_RENEW &&
+	    state != DHCP6S_REBIND &&
+	    state != DHCP6S_RELEASE &&
+	    (state != DHCP6S_SOLICIT || !(ifp->send_flags & DHCIFF_RAPID_COMMIT))
+	   ) {
+		bb_error_msg("unexpected reply");
+		return -1;
+	}
+
+	/*
+	 * If the client included a Rapid Commit option in the Solicit message,
+	 * the client discards any Reply messages it receives that do not
+	 * include a Rapid Commit option.
+	 * (should we keep the server otherwise?)
+	 * [RFC3315 Section 17.1.4]
+	 */
+	if (state == DHCP6S_SOLICIT &&
+	    (ifp->send_flags & DHCIFF_RAPID_COMMIT) && !optinfo->rapidcommit) {
+		bb_error_msg("no rapid commit");
+		return -1;
+	}
+
+	/*
+	 * The client MAY choose to report any status code or message from the
+	 * status code option in the Reply message.
+	 * [RFC3315 Section 18.1.8]
+	 */
+	TAILQ_FOREACH(lv, &optinfo->stcode_list, link) {
+		bb_error_msg("status code: %s", dhcp6stcodestr(lv->val_num16));
+	}
+
+	/*
+	 * Set refresh timer for configuration information specified in
+	 * information-request.  If the timer value is specified by the server
+	 * in an information refresh time option, use it; use the protocol
+	 * default otherwise.
+	 */
+	if (state == DHCP6S_INFOREQ) {
+		unsigned long long refreshtime = DHCP6_IRT_DEFAULT;
+
+		if (optinfo->refreshtime != -1)
+			refreshtime = optinfo->refreshtime;
+
+		ifp->timer = dhcp6_timer_add(client6_expire_refreshtime, ifp);
+
+		if (refreshtime > 0x7fffffffULL) {
+			/*
+			 * XXX: tv_sec can overflow for an
+			 * unsigned 32bit value.
+			 */
+			bb_error_msg("refresh time is too large: %llu", refreshtime);
+			refreshtime = 0x7fffffffULL;
+		}
+		refreshtime *= 1000ULL;
+		dhcp6_timer_set(refreshtime, ifp->timer);
+
+	} else if (optinfo->refreshtime != -1) {
+		/*
+		 * draft-ietf-dhc-lifetime-02 clarifies that refresh time
+		 * is only used for information-request and reply exchanges.
+		 */
+		bb_error_msg("unexpected information refresh time option (ignored)");
+	}
+
+	/* update stateful configuration information */
+	if (state != DHCP6S_RELEASE) {
+		update_ia(&optinfo->ia_list, ifp, &optinfo->serverID IF_FEATURE_DHCP6_AUTH(, ev->authparam));
+	}
+
+	/*
+	 * Call the configuration script, if specified, to handle various
+	 * configuration parameters.
+	 */
+	if (ifp->scriptpath != NULL) {
+		log1("executes %s", ifp->scriptpath);
+		dhcp6_script(ifp->scriptpath, fill_envp_client6(optinfo, ifp->ifname));
+	}
+
+	dhcp6_remove_event(ev);
+
+	if (state == DHCP6S_RELEASE) {
+		/*
+		 * When the client receives a valid Reply message in response
+		 * to a Release message, the client considers the Release event
+		 * completed, regardless of the Status Code option(s) returned
+		 * by the server.
+		 * [RFC3315 Section 18.1.8]
+		 */
+		check_exit(0);
+	}
+
+	log1("got an expected reply, sleeping");
+
+	if (option_mask32 & OPT_i) {
+		check_exit(1);
+	}
+	return 0;
+}
+
+static struct dhcp6_event *find_event_withid(unsigned int ifid, uint32_t xid)
+{
+	struct dhcp6_event *ev;
+
+	TAILQ_FOREACH(ev, &client6_config.event_list, link) {
+		if (ev->xid == xid && ev->ifp->ifid == ifid)
+			return ev;
+	}
+
+	return NULL;
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int
+process_auth(struct authparam *authparam, struct dhcp6 *dh6, ssize_t len,
+	     struct dhcp6_optinfo *optinfo)
+{
+	struct keyinfo *key = NULL;
+	int authenticated = 0;
+
+	switch (optinfo->authproto) {
+	case -1:
+		/* server did not provide authentication option */
+		break;
+	case DHCP6_AUTHPROTO_DELAYED:
+		if ((optinfo->authflags & DHCP6OPT_AUTHFLAG_NOINFO)) {
+			bb_error_msg("server did not include authentication information");
+			break;
+		}
+
+		if (optinfo->authalgorithm != DHCP6_AUTHALG_HMACMD5) {
+			bb_error_msg("unknown authentication algorithm: %d",
+				 optinfo->authalgorithm);
+			break;
+		}
+
+		if (optinfo->authrdm != DHCP6_AUTHRDM_MONOCOUNTER) {
+			bb_error_msg("unsupported replay detection method (%d)",
+				optinfo->authrdm);
+			break;
+		}
+
+		/*
+		 * Replay protection.  If we do not know the previous RD value,
+		 * we accept the message anyway (XXX).
+		 */
+		if ((authparam->flags & AUTHPARAM_FLAGS_NOPREVRD)) {
+			bb_error_msg("previous RD value is unknown (accept it)");
+		} else {
+			if (dhcp6_auth_replaycheck(optinfo->authrdm,
+			    authparam->prevrd, optinfo->authrd)) {
+				bb_error_msg("possible replay attack detected");
+				break;
+			}
+		}
+
+		/* identify the secret key */
+		key = authparam->key;
+		if (key != NULL) {
+			/*
+			 * If we already know a key, its identification should
+			 * match that contained in the received option.
+			 * (from Section 21.4.5.1 of RFC3315)
+			 */
+			if (optinfo->delayedauth_keyid != key->keyid ||
+				dhcp6_vbuf_cmp(&optinfo->authinfo.aiu_delayed.realm,
+							   &key->realm) != 0) {
+				bb_error_msg("authentication key mismatch");
+				break;
+			}
+		} else {
+			key = find_key(&optinfo->authinfo.aiu_delayed.realm,
+			    optinfo->delayedauth_keyid);
+			if (key == NULL) {
+				bb_error_msg("can't find server key (ID: %x)",
+				    optinfo->delayedauth_keyid);
+				break;
+			} else {
+				log1("found key for authentication: %s", key->name);
+			}
+			authparam->key = key;
+		}
+
+		/* check for the key lifetime */
+		if (dhcp6_validate_key(key)) {
+			bb_error_msg("auth key %s has expired", key->name);
+			break;
+		}
+
+		/* validate MAC */
+		if (dhcp6_verify_mac((char *)dh6, len, optinfo->authproto,
+		    optinfo->authalgorithm,
+		    optinfo->delayedauth_offset + sizeof(*dh6), key) == 0) {
+			log1("message authentication validated");
+			authenticated = 1;
+		} else {
+			bb_error_msg("invalid message authentication");
+		}
+
+		break;
+	default:
+		bb_error_msg("unsupported authentication protocol: %d",
+			 optinfo->authproto);
+		break;
+	}
+
+	if (authenticated == 0) {
+		if (authparam->authproto != -1) {
+			bb_error_msg("message not authenticated "
+			    "while authentication required");
+
+			/*
+			 * Right now, we simply discard unauthenticated
+			 * messages.
+			 */
+			return -1;
+		}
+	} else {
+		/* if authenticated, update the "previous" RD value */
+		authparam->prevrd = optinfo->authrd;
+		authparam->flags &= ~AUTHPARAM_FLAGS_NOPREVRD;
+	}
+
+	return 0;
+}
+
+static int set_auth(struct dhcp6_event *ev, struct dhcp6_optinfo *optinfo)
+{
+	struct authparam *authparam = ev->authparam;
+
+	if (authparam == NULL)
+		return 0;
+
+	optinfo->authproto = authparam->authproto;
+	optinfo->authalgorithm = authparam->authalgorithm;
+	optinfo->authrdm = authparam->authrdm;
+
+	switch (authparam->authproto) {
+	case -1: /* we simply do not need authentication */
+		return 0;
+	case DHCP6_AUTHPROTO_DELAYED:
+		if (ev->state == DHCP6S_INFOREQ) {
+			/*
+			 * In the current implementation, delayed
+			 * authentication for Information-request and Reply
+			 * exchanges doesn't work.  Specification is also
+			 * unclear on this usage.
+			 */
+			bb_error_msg("delayed authentication "
+			    "cannot be used for Information-request yet");
+			return -1;
+		}
+
+		if (ev->state == DHCP6S_SOLICIT) {
+			optinfo->authflags |= DHCP6OPT_AUTHFLAG_NOINFO;
+			return 0; /* no auth information is needed */
+		}
+
+		if (authparam->key == NULL) {
+			bb_error_msg("no authentication key");
+			return -1;
+		}
+
+		if (dhcp6_validate_key(authparam->key)) {
+			bb_error_msg("auth key %s is invalid", authparam->key->name);
+			return -1;
+		}
+
+		if (get_rdvalue(optinfo->authrdm, &optinfo->authrd)) {
+			return -1;
+		}
+
+		optinfo->delayedauth_keyid = authparam->key->keyid;
+		dhcp6_vbuf_copy(&optinfo->authinfo.aiu_delayed.realm,
+			&authparam->key->realm);
+		break;
+	default:
+		bb_error_msg("unsupported authentication protocol: %d",
+		    authparam->authproto);
+		return -1;
+	}
+
+	return 0;
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH*/
diff -urN busybox-1.36.1-ref/networking/udhcp/dhcp6c.h busybox-1.36.1/networking/udhcp/dhcp6c.h
--- busybox-1.36.1-ref/networking/udhcp/dhcp6c.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.36.1/networking/udhcp/dhcp6c.h	2023-05-19 23:01:27.857391888 +0300
@@ -0,0 +1,185 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2003 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/* XXX: bsdi4 does not have TAILQ_EMPTY */
+#ifndef TAILQ_EMPTY
+#define	TAILQ_EMPTY(head) ((head)->tqh_first == NULL)
+#endif
+
+/* and linux *_FIRST and *_NEXT */
+#ifndef LIST_EMPTY
+#define	LIST_EMPTY(head)	((head)->lh_first == NULL)
+#endif
+#ifndef LIST_FIRST
+#define	LIST_FIRST(head)	((head)->lh_first)
+#endif
+#ifndef LIST_NEXT
+#define	LIST_NEXT(elm, field)	((elm)->field.le_next)
+#endif
+#ifndef TAILQ_FIRST
+#define	TAILQ_FIRST(head)	((head)->tqh_first)
+#endif
+#ifndef TAILQ_LAST
+#define	TAILQ_LAST(head, headname)					\
+	(*(((struct headname *)((head)->tqh_last))->tqh_last))
+#endif
+#ifndef TAILQ_PREV
+#define	TAILQ_PREV(elm, headname, field)				\
+	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))
+#endif
+#ifndef TAILQ_NEXT
+#define	TAILQ_NEXT(elm, field) ((elm)->field.tqe_next)
+#endif
+#ifndef TAILQ_FOREACH
+#define	TAILQ_FOREACH(var, head, field)					\
+	for ((var) = TAILQ_FIRST((head));				\
+	    (var);							\
+	    (var) = TAILQ_NEXT((var), field))
+#endif
+
+#define xstr(s)		_xstr(s)
+#define	_xstr(s)	#s
+
+#include "common.h"
+#include "dhcp6.h"
+#include "dhcp6c_config.h"
+
+PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN
+
+/* common6.c */
+struct dhcp6_option_typelen_t {
+	uint8_t	lvtype;
+	uint8_t	minlen;
+};
+
+extern const struct dhcp6_option_typelen_t dhcp6_option_typelens[D6_OPT__MAX+1];
+
+/* daemon state code */
+enum {
+	DHCP6S_INIT		= 0,
+	DHCP6S_SOLICIT	= DH6_SOLICIT,
+	DHCP6S_REQUEST	= DH6_REQUEST,
+	DHCP6S_RENEW	= DH6_RENEW,
+	DHCP6S_REBIND	= DH6_REBIND,
+	DHCP6S_RELEASE	= DH6_RELEASE,
+	DHCP6S_INFOREQ	= DH6_INFORM_REQ,
+};
+
+/* search option for dhcp6_find_listval() */
+enum {
+	MATCHLIST_PREFIXLEN	= (1 << 0),			/* Match prefix length only */
+	MATCHLIST_DH6OPTYPE	= (1 << 1),			/* Match by option type rather than listvalue type */
+};
+
+int dhcp6_copy_list(struct dhcp6_list *dst, const struct dhcp6_list *src);
+void dhcp6_move_list(struct dhcp6_list *dst, struct dhcp6_list *src);
+void dhcp6_clear_list(struct dhcp6_list *);
+void dhcp6_clear_listval(struct dhcp6_listval *);
+struct dhcp6_listval *dhcp6_find_listval(struct dhcp6_list *head,
+    int type, const void *val, int options);
+struct dhcp6_listval *dhcp6_add_listval(struct dhcp6_list *head,
+    int dh6optype, dhcp6_listval_type_t type,
+    const void *val, struct dhcp6_list *sublist);
+struct authparam *new_authparam(int proto, int alg, int rdm) RETURNS_MALLOC;
+int prefix6_mask(struct in6_addr *in6, int plen);
+int get_duid(const char *, struct dhcp6_vbuf *, int);
+void dhcp6_init_options(struct dhcp6_optinfo *);
+void dhcp6_clear_options(struct dhcp6_optinfo *);
+void dhcp6_copy_options(struct dhcp6_optinfo *,
+			   struct dhcp6_optinfo *);
+int dhcp6_get_options(struct dhcp6opt *, struct dhcp6opt *,
+			struct dhcp6_optinfo *);
+int dhcp6_set_options(int, struct dhcp6opt *, struct dhcp6opt *,
+			struct dhcp6_optinfo *);
+void dhcp6_set_timeoparam(struct dhcp6_event *);
+void dhcp6_reset_timer(struct dhcp6_event *);
+
+const char *dhcp6optstr(int);
+const char *dhcp6msgstr(int);
+const char *dhcp6stcodestr(uint16_t);
+char *duidstr(struct dhcp6_vbuf *);
+const char *dhcp6_event_statestr(struct dhcp6_event *);
+int get_rdvalue(int, void *);
+
+void dhcp6_vbuf_copy(struct dhcp6_vbuf *, struct dhcp6_vbuf *);
+void dhcp6_vbuf_free(struct dhcp6_vbuf *);
+static int ALWAYS_INLINE dhcp6_vbuf_cmp(struct dhcp6_vbuf *v1, struct dhcp6_vbuf *v2)
+{
+	if (v1->dv_len != v2->dv_len)
+		return (v1->dv_len - v2->dv_len);
+
+	return memcmp(v1->dv_buf, v2->dv_buf, v1->dv_len);
+}
+
+/* timer functions */
+struct dhcp6_timer {
+	LIST_ENTRY(dhcp6_timer) link;
+
+	unsigned long long t;
+
+	struct dhcp6_timer *(*expire)(void *);
+	void *expire_data;
+};
+
+struct dhcp6_timer *dhcp6_timer_add(struct dhcp6_timer *(*)(void *), void *);
+void dhcp6_timer_set(unsigned long long , struct dhcp6_timer *);
+void dhcp6_timer_remove(struct dhcp6_timer **);
+struct timeval *dhcp6_timer_check(void);
+unsigned long long dhcp6_timer_rest(struct dhcp6_timer *);
+
+/* dhcp6c_socket.c */
+typedef enum { IFADDRCONF_ADD, IFADDRCONF_REMOVE } ifaddrconf_cmd_t;
+
+int sock6_init(const char *boundaddr, const char *port);
+
+int ifaddrconf(ifaddrconf_cmd_t, const char *ifname, struct in6_addr *,
+			int plen, int pltime, int vltime);
+
+/* dhcp6c_script.c */
+char **fill_envp_client6(struct dhcp6_optinfo *optinfo, const char *ifname);
+char **fill_envp_relay6(struct dhcp6_optinfo *optinfo, const char *clientaddr);
+int dhcp6_script(const char *scriptpath, char **envp);
+
+/* dhcp6c_ia.c */
+void update_ia(struct dhcp6_list *iahead, struct dhcp6_if *ifp,
+		struct dhcp6_vbuf *serverid
+		IF_FEATURE_DHCP6_AUTH(, struct authparam *));
+void release_all_ia(struct dhcp6_if *);
+
+/* dhcp6c.c */
+#define MAX_ELAPSED_TIME 0xffff
+
+struct dhcp6_event *dhcp6_create_event(const struct dhcp6_if *, int) RETURNS_MALLOC;
+void dhcp6_remove_event(struct dhcp6_event *);
+
+int client6_start(struct dhcp6_if *);
+void client6_send(struct dhcp6_event *);
+
+POP_SAVED_FUNCTION_VISIBILITY
diff -urN busybox-1.36.1-ref/networking/udhcp/dhcp6c_auth.c busybox-1.36.1/networking/udhcp/dhcp6c_auth.c
--- busybox-1.36.1-ref/networking/udhcp/dhcp6c_auth.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.36.1/networking/udhcp/dhcp6c_auth.c	2023-05-19 23:01:27.857391888 +0300
@@ -0,0 +1,234 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2004 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+/*
+ * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
+ * Copyright (C) 2000, 2001  Internet Software Consortium.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
+ * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
+ * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+ * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
+ * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "common.h"
+#include "dhcp6.h"
+#include "dhcp6c_auth.h"
+
+#define HMACMD5_KEYLENGTH	64
+#define MD5_DIGESTLENGTH	16
+
+typedef struct {
+	md5_ctx_t md5ctx;
+	unsigned char key[HMACMD5_KEYLENGTH];
+} hmacmd5_t;
+
+
+static void hmacmd5_init(hmacmd5_t *, const unsigned char *, unsigned int);
+static void hmacmd5_sign(hmacmd5_t *, unsigned char *);
+static int hmacmd5_verify(hmacmd5_t *, unsigned char *);
+
+
+int dhcp6_validate_key(struct keyinfo *key)
+{
+	time_t now;
+
+	if (key->expire == 0)	/* never expire */
+		return 0;
+
+	time(&now);
+	if (now > key->expire)
+		return -1;
+
+	return 0;
+}
+
+int dhcp6_calc_mac(char *buf, size_t len, int proto UNUSED_PARAM,
+		int alg, size_t off, struct keyinfo *key)
+{
+	hmacmd5_t ctx;
+	unsigned char digest[MD5_DIGESTLENGTH];
+
+	/* right now, we don't care about the protocol */
+
+	if (alg != DHCP6_AUTHALG_HMACMD5)
+		return -1;
+
+	if (off + MD5_DIGESTLENGTH > len) {
+		/*
+		 * this should be assured by the caller, but check it here
+		 * for safety.
+		 */
+		return -2;
+	}
+
+	hmacmd5_init(&ctx, key->secret, key->secretlen);
+	md5_hash(&ctx.md5ctx, buf, len);
+	hmacmd5_sign(&ctx, digest);
+
+	memcpy(buf + off, digest, MD5_DIGESTLENGTH);
+
+	return 0;
+}
+
+int dhcp6_verify_mac(char *buf, ssize_t len, int proto UNUSED_PARAM,
+		 int alg, size_t off, struct keyinfo *key)
+{
+	hmacmd5_t ctx;
+	unsigned char digest[MD5_DIGESTLENGTH];
+	int result;
+
+	/* right now, we don't care about the protocol */
+
+	if (alg != DHCP6_AUTHALG_HMACMD5)
+		return -1;
+
+	if (off + MD5_DIGESTLENGTH > len)
+		return -1;
+
+	/*
+	 * Copy the MAC value and clear the field.
+	 * XXX: should we make a local working copy?
+	 */
+	memcpy(digest, buf + off, sizeof(digest));
+	memset(buf + off, 0, sizeof(digest));
+
+	hmacmd5_init(&ctx, key->secret, key->secretlen);
+	md5_hash(&ctx.md5ctx, buf, len);
+	result = hmacmd5_verify(&ctx, digest);
+
+	/* copy back the digest value (XXX) */
+	memcpy(buf + off, digest, sizeof(digest));
+
+	return result;
+}
+
+int dhcp6_auth_replaycheck(int method, uint64_t prev, uint64_t current)
+{
+
+	if (method != DHCP6_AUTHRDM_MONOCOUNTER) {
+		bb_error_msg("unsupported replay detection method (%d)", method);
+		return -1;
+	}
+
+	log1("previous: %llx, current: %llx", SWAP_BE64(prev), SWAP_BE64(current));
+
+	prev = SWAP_BE64(prev);
+	current = SWAP_BE64(current);
+
+	/*
+	 * we call the singular point guilty, since we cannot guess
+	 * whether the serial number is increasing or not.
+	 */
+	if (prev == (current ^ 0x8000000000000000ULL)) {
+		bb_error_msg("detected a singular point");
+		return 1;
+	}
+
+	return (((int64_t )(current - prev) > 0) ? 0 : 1);
+}
+
+
+/*
+ * This code implements the HMAC-MD5 keyed hash algorithm
+ * described in RFC 2104.
+ */
+
+#define PADLEN 64
+#define IPAD   0x36
+#define OPAD   0x5C
+
+/*
+ * Start HMAC-MD5 process.  Initialize an md5 context and digest the key.
+ */
+static void hmacmd5_init(hmacmd5_t *ctx,
+				 const unsigned char *key, unsigned int len)
+{
+	unsigned char ipad[PADLEN];
+	int i;
+
+	memset(ctx->key, 0, sizeof(ctx->key));
+	if (len > sizeof(ctx->key)) {
+		md5_ctx_t md5ctx;
+
+		md5_begin(&md5ctx);
+		md5_hash(&md5ctx, key, len);
+		md5_end(&md5ctx, ctx->key);
+	} else {
+		memcpy(ctx->key, key, len);
+	}
+
+	md5_begin(&ctx->md5ctx);
+	memset(ipad, IPAD, sizeof(ipad));
+	for (i = 0; i < PADLEN; i++) {
+		ipad[i] ^= ctx->key[i];
+	}
+
+	md5_hash(&ctx->md5ctx, ipad, sizeof(ipad));
+}
+
+/*
+ * Compute signature - finalize MD5 operation and reapply MD5.
+ */
+static void hmacmd5_sign(hmacmd5_t *ctx, unsigned char *digest)
+{
+	unsigned char opad[PADLEN];
+	int i;
+
+	md5_end(&ctx->md5ctx, digest);
+
+	memset(opad, OPAD, sizeof(opad));
+	for (i = 0; i < PADLEN; i++) {
+		opad[i] ^= ctx->key[i];
+	}
+
+	md5_begin(&ctx->md5ctx);
+	md5_hash(&ctx->md5ctx, opad, sizeof(opad));
+	md5_hash(&ctx->md5ctx, digest, MD5_DIGESTLENGTH);
+	md5_end(&ctx->md5ctx, digest);
+	memset(ctx, 0, sizeof(*ctx));
+}
+
+/*
+ * Verify signature - finalize MD5 operation and reapply MD5, then
+ * compare to the supplied digest.
+ */
+static int hmacmd5_verify(hmacmd5_t *ctx, unsigned char *digest) {
+	unsigned char newdigest[MD5_DIGESTLENGTH];
+
+	hmacmd5_sign(ctx, newdigest);
+	return memcmp(digest, newdigest, MD5_DIGESTLENGTH);
+}
diff -urN busybox-1.36.1-ref/networking/udhcp/dhcp6c_auth.h busybox-1.36.1/networking/udhcp/dhcp6c_auth.h
--- busybox-1.36.1-ref/networking/udhcp/dhcp6c_auth.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.36.1/networking/udhcp/dhcp6c_auth.h	2023-05-19 23:01:27.857391888 +0300
@@ -0,0 +1,51 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2004 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN
+
+/* secret key information for delayed authentication */
+struct keyinfo {
+	struct keyinfo *next;
+
+	char *name;				/* key name */
+
+	struct dhcp6_vbuf realm;/* DHCP realm */
+	uint32_t keyid;			/* key ID */
+	unsigned char *secret;	/* binary key */
+	size_t secretlen;		/* length of the key */
+	time_t expire;			/* expiration time (0 means forever) */
+};
+
+int dhcp6_validate_key(struct keyinfo *);
+int dhcp6_calc_mac(char *, size_t, int, int, size_t, struct keyinfo *);
+int dhcp6_verify_mac(char *, ssize_t, int, int, size_t, struct keyinfo *);
+int dhcp6_auth_replaycheck(int, uint64_t, uint64_t);
+
+POP_SAVED_FUNCTION_VISIBILITY
diff -urN busybox-1.36.1-ref/networking/udhcp/dhcp6c_common.c busybox-1.36.1/networking/udhcp/dhcp6c_common.c
--- busybox-1.36.1-ref/networking/udhcp/dhcp6c_common.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.36.1/networking/udhcp/dhcp6c_common.c	2023-05-19 23:01:27.857391888 +0300
@@ -0,0 +1,1856 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 1998 and 1999 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <net/if.h>
+#include <netinet/in.h>
+#include <netinet/if_ether.h>		// for hwid only
+#include <limits.h>
+#include <netdb.h>
+
+#include "dhcp6c.h"
+
+
+static int copyin_option(int, struct dhcp6opt *, struct dhcp6opt *,
+    struct dhcp6_list *);
+static int copy_option(uint16_t, uint16_t, void *, struct dhcp6opt **,
+    struct dhcp6opt *, int *);
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int copyout_auth(struct dhcp6_optinfo *optinfo,
+		struct dhcp6opt **pp, struct dhcp6opt *bp, struct dhcp6opt *ep,
+		int *totallenp);
+# if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 2
+static char *sprint_auth(struct dhcp6_optinfo *);
+# endif
+#endif
+
+const struct dhcp6_option_typelen_t dhcp6_option_typelens[D6_OPT__MAX+1] = {
+	[D6_OPT_CLIENTID]       = { DHCP6_LISTVAL_VBUF, 1                          },
+	[D6_OPT_SERVERID]       = { DHCP6_LISTVAL_VBUF, 1                          },
+	[D6_OPT_IA_NA]          = { DHCP6_LISTVAL_IA, sizeof(struct dhcp6opt_ia)-4 },
+//	[D6_OPT_IA_TA]          = { 0, 0 },
+	[D6_OPT_IAADDR]         = { DHCP6_LISTVAL_STATEFULADDR6, sizeof(struct dhcp6opt_ia_addr)-4 },
+	[D6_OPT_ORO]            = { DHCP6_LISTVAL_NUM16, sizeof(uint16_t)          },
+	[D6_OPT_PREFERENCE]     = { DHCP6_LISTVAL_NUM8, 1                          },
+	[D6_OPT_ELAPSED_TIME]   = { DHCP6_LISTVAL_NUM16, sizeof(uint16_t)          },
+	[D6_OPT_RELAY_MSG]      = { DHCP6_LISTVAL_VBUF, 1                          },
+	[D6_OPT_AUTH]           = { 0, sizeof(struct dhcp6opt_auth)-4              },
+//	[D6_OPT_UNICAST]		= { 0, 0 },
+	[D6_OPT_STATUS_CODE]    = { DHCP6_LISTVAL_NUM16, sizeof(uint16_t)          },
+	[D6_OPT_RAPID_COMMIT]   = { DHCP6_LISTVAL_NUM8, 0                          },
+//	[D6_OPT_USER_CLASS]     = { 0, 0 },
+//	[D6_OPT_VENDOR_CLASS]   = { 0, 0 },
+//	[D6_OPT_VENDOR_OPTS]    = { 0, 0 },
+	[D6_OPT_INTERFACE_ID]   = { DHCP6_LISTVAL_VBUF, 1                          },
+//	[D6_OPT_RECONF_MSG]     = { 0, 0 },
+	[D6_OPT_SIP_SERVER_D]   = { DHCP6_LISTVAL_VBUF, 1                          },
+	[D6_OPT_SIP_SERVER_A]   = { DHCP6_LISTVAL_ADDR6, sizeof(struct in6_addr)   },
+	[D6_OPT_DNS]            = { DHCP6_LISTVAL_ADDR6, sizeof(struct in6_addr)   },
+	[D6_OPT_DNSNAME]        = { DHCP6_LISTVAL_VBUF, 1                          },
+	[D6_OPT_IA_PD]          = { DHCP6_LISTVAL_IA, sizeof(struct dhcp6opt_ia)-4 },
+	[D6_OPT_IA_PD_PREFIX]   = { DHCP6_LISTVAL_PREFIX6, sizeof(struct dhcp6opt_ia_pd_prefix)-4 },
+	[D6_OPT_NIS_SERVERS]    = { DHCP6_LISTVAL_ADDR6, sizeof(struct in6_addr) },
+	[D6_OPT_NISP_SERVERS]   = { DHCP6_LISTVAL_ADDR6, sizeof(struct in6_addr) },
+	[D6_OPT_NIS_DOMAIN]     = { DHCP6_LISTVAL_VBUF, 1                          },
+	[D6_OPT_NISP_DOMAIN]    = { DHCP6_LISTVAL_VBUF, 1                          },
+	[D6_OPT_SNTP_SERVERS]   = { DHCP6_LISTVAL_ADDR6, sizeof(struct in6_addr)   },
+	[D6_OPT_REFRESHTIME]    = { DHCP6_LISTVAL_NUM,	sizeof(uint32_t)           },
+	[D6_OPT_BCMCS_SERVER_D] = { DHCP6_LISTVAL_VBUF, 1                          },
+	[D6_OPT_BCMCS_SERVER_A] = { DHCP6_LISTVAL_ADDR6, sizeof(struct in6_addr)   },
+//	[D6_OPT_GEOCONF_CIVIC]  = { 0, 0 },
+//	[D6_OPT_REMOTE_ID]      = { 0, 0 },
+//	[D6_OPT_SUBSCRIBER_ID]  = { 0, 0 },
+//	[D6_OPT_CLIENT_FQDN]    = { 0, 0 },
+	[D6_OPT_NTP_SERVER]     = { DHCP6_LISTVAL_ADDR6, sizeof(struct in6_addr)   },
+};
+
+int dhcp6_copy_list(struct dhcp6_list *dst, const struct dhcp6_list *src)
+{
+	struct dhcp6_listval *ent;
+
+	TAILQ_FOREACH(ent, src, link) {
+		if (dhcp6_add_listval(dst, ent->dh6optype, ent->lvtype,
+		    &ent->uv, &ent->sublist) == NULL)
+			return -1;
+	}
+
+	return 0;
+}
+
+void dhcp6_move_list(struct dhcp6_list *dst, struct dhcp6_list *src)
+{
+	struct dhcp6_listval *lv;
+
+	while ((lv = TAILQ_FIRST(src)) != NULL) {
+		TAILQ_REMOVE(src, lv, link);
+		TAILQ_INSERT_TAIL(dst, lv, link);
+	}
+}
+
+void dhcp6_clear_list(struct dhcp6_list *head)
+{
+	struct dhcp6_listval *lv;
+
+	while ((lv = TAILQ_FIRST(head)) != NULL) {
+		TAILQ_REMOVE(head, lv, link);
+		dhcp6_clear_listval(lv);
+	}
+}
+
+void dhcp6_clear_listval(struct dhcp6_listval *lv)
+{
+	dhcp6_clear_list(&lv->sublist);
+	switch (lv->lvtype) {
+	case DHCP6_LISTVAL_VBUF:
+		dhcp6_vbuf_free(&lv->val_vbuf);
+		break;
+	default:		/* nothing to do */
+		break;
+	}
+	free(lv);
+}
+
+/*
+ * Note: this function only searches for the first entry that matches
+ * VAL.  It also does not care about sublists.
+ */
+struct dhcp6_listval *dhcp6_find_listval(struct dhcp6_list *head,
+		int type, const void *val, int option)
+{
+	struct dhcp6_listval *lv;
+
+	TAILQ_FOREACH(lv, head, link) {
+		if (option & MATCHLIST_DH6OPTYPE) {
+			if (lv->dh6optype != type)
+				continue;
+		} else {
+			if (lv->lvtype != type)
+				continue;
+		}
+
+		switch (lv->lvtype) {
+		case DHCP6_LISTVAL_NUM:
+			if (lv->val_num == *(int32_t *)val)
+				return lv;
+			break;
+		case DHCP6_LISTVAL_NUM16:
+			if (lv->val_num16 == *(uint16_t *)val)
+				return lv;
+			break;
+		case DHCP6_LISTVAL_NUM8:
+			if (lv->val_num8 == *(uint8_t *)val)
+				return lv;
+			break;
+		case DHCP6_LISTVAL_ADDR6:
+			if (IN6_ARE_ADDR_EQUAL(&lv->val_addr6, (struct in6_addr *)val)) {
+				return lv;
+			}
+			break;
+		case DHCP6_LISTVAL_PREFIX6:
+			if ((option & MATCHLIST_PREFIXLEN) &&
+			    lv->val_prefix6.plen == ((struct dhcp6_prefix *)val)->plen) {
+				return lv;
+			} else if (IN6_ARE_ADDR_EQUAL(&lv->val_prefix6.addr,
+			    &((struct dhcp6_prefix *)val)->addr) &&
+			    lv->val_prefix6.plen == ((struct dhcp6_prefix *)val)->plen) {
+				return lv;
+			}
+			break;
+		case DHCP6_LISTVAL_STATEFULADDR6:
+			if (IN6_ARE_ADDR_EQUAL(&lv->val_statefuladdr6.addr,
+			    &((struct dhcp6_prefix *)val)->addr)) {
+				return lv;
+			}
+			break;
+		case DHCP6_LISTVAL_IA:
+			if (lv->val_ia.iaid == ((struct dhcp6_ia *)val)->iaid) {
+				return lv;
+			}
+			break;
+		case DHCP6_LISTVAL_VBUF:
+			if (dhcp6_vbuf_cmp(&lv->val_vbuf, (struct dhcp6_vbuf *)val) == 0) {
+				return lv;
+			}
+			break;
+		}
+	}
+
+	return NULL;
+}
+
+struct dhcp6_listval *dhcp6_add_listval(struct dhcp6_list *head,
+		int dh6optype, dhcp6_listval_type_t lvtype,
+		const void *val, struct dhcp6_list *sublist)
+{
+	struct dhcp6_listval *lv;
+
+	lv = xzalloc(sizeof(*lv));
+	lv->dh6optype = dh6optype;
+	lv->lvtype = lvtype;
+	TAILQ_INIT(&lv->sublist);
+
+	switch (lvtype) {
+	case DHCP6_LISTVAL_NUM:
+		lv->val_num = *(int *)val;
+		break;
+	case DHCP6_LISTVAL_NUM16:
+		lv->val_num16 = *(uint16_t *)val;
+		break;
+	case DHCP6_LISTVAL_NUM8:
+		lv->val_num8 = *(uint8_t *)val;
+		break;
+	case DHCP6_LISTVAL_ADDR6:
+		lv->val_addr6 = *(struct in6_addr *)val;
+		break;
+	case DHCP6_LISTVAL_PREFIX6:
+		lv->val_prefix6 = *(struct dhcp6_prefix *)val;
+		break;
+	case DHCP6_LISTVAL_STATEFULADDR6:
+		lv->val_statefuladdr6 = *(struct dhcp6_statefuladdr *)val;
+		break;
+	case DHCP6_LISTVAL_IA:
+		lv->val_ia = *(struct dhcp6_ia *)val;
+		break;
+	case DHCP6_LISTVAL_VBUF:
+		dhcp6_vbuf_copy(&lv->val_vbuf, (struct dhcp6_vbuf *)val);
+		break;
+	default:
+		bb_error_msg("option '%s': unexpected list value type (%d)",
+				dhcp6optstr(dh6optype), lvtype);
+		free(lv);
+		return NULL;
+	}
+
+	if (sublist)
+		dhcp6_copy_list(&lv->sublist, sublist);
+
+	TAILQ_INSERT_TAIL(head, lv, link);
+	return lv;
+}
+
+void dhcp6_vbuf_copy(struct dhcp6_vbuf *dst, struct dhcp6_vbuf *src)
+{
+	dst->dv_len = src->dv_len;
+	if (dst->dv_len == 0)
+		return;
+
+	dst->dv_buf = xmemdup(src->dv_buf, dst->dv_len);
+}
+
+void dhcp6_vbuf_free(struct dhcp6_vbuf *vbuf)
+{
+	free(vbuf->dv_buf);
+
+	vbuf->dv_len = 0;
+	vbuf->dv_buf = NULL;
+}
+
+struct dhcp6_timer *dhcp6_timer_add(struct dhcp6_timer *(*timeout)(void *),
+				    void *timeodata)
+{
+	struct dhcp6_timer *newtimer;
+
+	if (timeout == NULL) {
+		log1("timeout function unspecified");
+		return NULL;
+	}
+
+	newtimer = xzalloc(sizeof(*newtimer));
+	newtimer->expire = timeout;
+	newtimer->expire_data = timeodata;
+	newtimer->t = ULLONG_MAX;
+
+	LIST_INSERT_HEAD(&client6_config.timer_head, newtimer, link);
+
+	return newtimer;
+}
+
+void dhcp6_timer_remove(struct dhcp6_timer **timer)
+{
+	LIST_REMOVE(*timer, link);
+	free(*timer);
+	*timer = NULL;
+}
+
+void dhcp6_timer_set(unsigned long long t, struct dhcp6_timer *timer)
+{
+	timer->t = monotonic_ms() + t;
+
+	/* update the next expiration time */
+	if (timer->t < client6_config.tm_sentinel)
+		client6_config.tm_sentinel = timer->t;
+}
+
+/*
+ * Check expiration for each timer. If a timer is expired,
+ * call the expire function for the timer and update the timer.
+ * Return the next interval for select() call.
+ */
+struct timeval *dhcp6_timer_check(void)
+{
+	unsigned long long now = monotonic_ms();
+	struct dhcp6_timer *tm, *tm_next;
+
+	client6_config.tm_sentinel = ULLONG_MAX;
+	for (tm = LIST_FIRST(&client6_config.timer_head); tm; tm = tm_next) {
+		tm_next = LIST_NEXT(tm, link);
+
+		if ((long long)(now - tm->t) >= 0) {
+			if ((*tm->expire)(tm->expire_data) == NULL)
+				continue; /* timer has been freed */
+		}
+
+		if (tm->t < client6_config.tm_sentinel)
+			client6_config.tm_sentinel = tm->t;
+	}
+
+	if (ULLONG_MAX == client6_config.tm_sentinel) {
+		/* no need to timeout */
+		return NULL;
+	} else if (client6_config.tm_sentinel < now) {
+		/* this may occur when the interval is too small */
+		client6_config.tm_check.tv_sec = client6_config.tm_check.tv_usec = 0;
+	} else {
+		client6_config.tm_check.tv_sec =
+			(client6_config.tm_sentinel - now) / 1000ULL;
+		client6_config.tm_check.tv_usec =
+			((client6_config.tm_sentinel - now) % 1000ULL) * 1000ULL;
+	}
+	return (&client6_config.tm_check);
+}
+
+unsigned long long dhcp6_timer_rest(struct dhcp6_timer *timer)
+{
+	unsigned long long now = monotonic_ms();
+
+	if (timer->t - now <= 0) {
+		log2("a timer must be expired, but not yet");
+		return 0;
+	} else {
+		return (timer->t - now);
+	}
+}
+
+/* Domain names stored in RFC1035 format */
+#if ENABLE_FEATURE_UDHCP_RFC3397
+static int dhcp6_get_domain(int optlen, void *cp, int dh6optype,
+			    struct dhcp6_list *list)
+{
+	char *names, *p, *n;
+
+	names = dname_dec(cp, optlen, "");
+	if (names == NULL) {
+		bb_error_msg("can't decode %s", dhcp6optstr(dh6optype));
+		return -1;
+	}
+
+	log2("  domains: '%s'", names);
+
+	p = names;
+	while (*p) {
+		struct dhcp6_vbuf vb;
+
+		n = strchrnul(p, ' ');
+		vb.dv_buf = p;
+		vb.dv_len = n - p + 1;
+		if (*n)
+			*(n++) = '\0';
+
+		if (dhcp6_add_listval(list, dh6optype, DHCP6_LISTVAL_VBUF,
+				&vb, NULL) == NULL) {
+			free(names);
+			return -2;
+		}
+		p = n;
+	}
+	free(names);
+
+	return 0;
+}
+#endif /* FEATURE_UDHCP_RFC3397 */
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+struct authparam *new_authparam(int proto, int alg, int rdm)
+{
+	struct authparam *authparam;
+
+	authparam = xzalloc(sizeof(*authparam));
+
+	authparam->authproto = proto;
+	authparam->authalgorithm = alg;
+	authparam->authrdm = rdm;
+	authparam->key = NULL;
+	authparam->flags |= AUTHPARAM_FLAGS_NOPREVRD;
+	authparam->prevrd = 0;
+
+	return authparam;
+}
+
+static int copyout_auth(struct dhcp6_optinfo *optinfo,
+		struct dhcp6opt **pp, struct dhcp6opt *bp, struct dhcp6opt *ep,
+		int *totallenp)
+{
+	struct dhcp6opt_auth *auth;
+	int authlen;
+
+	authlen = sizeof(struct dhcp6opt_auth);
+	if (!(optinfo->authflags & DHCP6OPT_AUTHFLAG_NOINFO)) {
+		switch (optinfo->authproto) {
+		case DHCP6_AUTHPROTO_DELAYED:
+			/* Realm + key ID + HMAC-MD5 */
+			authlen += optinfo->delayedauth_realmlen +
+			    sizeof(optinfo->delayedauth_keyid) + 16;
+			break;
+#ifdef notyet
+		case DHCP6_AUTHPROTO_RECONFIG:
+			/* type + key-or-HAMC */
+			authlen += 17;
+			break;
+#endif
+		default:
+			bb_error_msg("unsupported authentication protocol: %d",
+				    optinfo->authproto);
+			goto fail;
+		}
+	}
+
+	if (ep - (*pp) < authlen)
+		return -1;
+
+	/* copy_option will take care of type and len later */
+	auth = (struct dhcp6opt_auth *)(*pp);
+	auth->dh6_proto = (uint8_t)optinfo->authproto;
+	auth->dh6_alg = (uint8_t)optinfo->authalgorithm;
+	auth->dh6_rdm = (uint8_t)optinfo->authrdm;
+	memcpy(auth->dh6_rdinfo, &optinfo->authrd, sizeof(auth->dh6_rdinfo));
+
+	if (!(optinfo->authflags & DHCP6OPT_AUTHFLAG_NOINFO)) {
+		char *authinfo;
+
+		switch (optinfo->authproto) {
+		case DHCP6_AUTHPROTO_DELAYED:
+			authinfo = (char *)(auth + 1);
+
+			/* copy realm */
+			memcpy(authinfo, optinfo->delayedauth_realmval,
+			    optinfo->delayedauth_realmlen);
+			authinfo += optinfo->delayedauth_realmlen;
+
+			/* copy key ID (unaligned!) */
+			move_to_unaligned32(authinfo, htonl(optinfo->delayedauth_keyid));
+
+			/*
+			 * Set the offset so that the caller can
+			 * calculate the HMAC.
+			 */
+			optinfo->delayedauth_offset = ((char *)(*pp) - (char *)bp)
+										+ authlen - 16;
+
+			log1("key ID %x, offset %d", optinfo->delayedauth_keyid,
+			    optinfo->delayedauth_offset);
+			break;
+#ifdef notyet
+		case DHCP6_AUTHPROTO_RECONFIG:
+#endif
+		default:
+			bb_error_msg("unsupported authentication protocol: %d",
+				    optinfo->authproto);
+			free(auth);
+			goto fail;
+		}
+	}
+
+	if (copy_option(D6_OPT_AUTH, authlen - 4, NULL, pp, ep, totallenp) != 0) {
+		goto fail;
+	}
+	return 0;
+
+ fail:
+	return -1;
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+static int sa6_plen2mask(struct sockaddr_in6 *sa6, int plen)
+{
+	uint8_t *cp;
+
+	if (plen < 0 || plen > 128)
+		return -1;
+
+	memset(sa6, 0, sizeof(*sa6));
+	sa6->sin6_family = AF_INET6;
+#ifdef HAVE_SA_LEN
+	sa6->sin6_len = sizeof(*sa6);
+#endif
+
+	for (cp = (uint8_t *)&sa6->sin6_addr; plen > 7; plen -= 8)
+		*cp++ = 0xff;
+	*cp = 0xff << (8 - plen);
+
+	return 0;
+}
+
+int prefix6_mask(struct in6_addr *in6, int plen)
+{
+	struct sockaddr_in6 mask6;
+	int i;
+
+	if (sa6_plen2mask(&mask6, plen))
+		return -1;
+
+	for (i = 0; i < 16; i++)
+		in6->s6_addr[i] &= mask6.sin6_addr.s6_addr[i];
+
+	return 0;
+}
+
+/* TODO! migrate to libbb functions
+  Get hardware id(MAC) of first ethernet interface for DUID
+ */
+static ssize_t gethwid(char *buf, uint16_t *hwtype)
+{
+	int n, numreqs = 30;
+	struct ifconf ifc;
+	struct ifreq *ifr;
+	int skfd;
+	ssize_t l = 0;
+
+	ifc.ifc_buf = NULL;
+	skfd = socket(AF_INET, SOCK_DGRAM, 0);
+	if (skfd < 0)
+		return -1;
+
+	/* query all available interfaces */
+	for (;;) {
+		ifc.ifc_len = sizeof(struct ifreq) * numreqs;
+		ifc.ifc_buf = xrealloc(ifc.ifc_buf, ifc.ifc_len);
+
+		if (ioctl_or_warn(skfd, SIOCGIFCONF, &ifc) < 0) {
+			goto out;
+		}
+		if (ifc.ifc_len == (int)(sizeof(struct ifreq) * numreqs)) {
+			/* assume it overflowed and try again */
+			numreqs += 10;
+			continue;
+		}
+		break;
+	}
+
+	/* search for acceptable hwaddr */
+	ifr = ifc.ifc_req;
+	for (n = 0; n < ifc.ifc_len; n += sizeof(struct ifreq), ifr++) {
+		if (ioctl(skfd, SIOCGIFHWADDR, ifr) != 0)
+			continue;
+		switch (ifr->ifr_hwaddr.sa_family) {
+			case ARPHRD_ETHER:
+			case ARPHRD_EETHER:
+			case ARPHRD_IEEE802:
+				memcpy(buf, ifr->ifr_hwaddr.sa_data, 8);
+				*hwtype = ifr->ifr_hwaddr.sa_family;
+				l = ETH_ALEN;
+				break;
+			default:
+				continue;
+		}
+		break;
+	}
+	if (l > 0)
+		log1("found an interface %s hwtype %d for DUID", ifr->ifr_name, *hwtype);
+
+ out:
+	close(skfd);
+	free(ifc.ifc_buf);
+	return l;
+}
+
+int get_duid(const char *idfile, struct dhcp6_vbuf *duid, int duid_type)
+{
+	int fd;
+	uint16_t len = 0, hwtype = 0;
+
+	fd = open(idfile, O_RDONLY);
+	if (fd < 0 && errno != ENOENT)
+		bb_error_msg("can't open DUID file: %s", idfile);
+
+	if (fd > 0) {
+		/* decode length */
+		if (safe_read(fd, &len, sizeof(len)) != sizeof(len)) {
+			bb_error_msg("DUID file corrupted");
+			goto fail;
+		}
+		duid->dv_len = len;
+		duid->dv_buf = xmalloc(len);
+
+		if (safe_read(fd, duid->dv_buf, len) != len) {
+			bb_error_msg("DUID file corrupted");
+			goto fail;
+		}
+
+		log1("extracted an existing DUID from %s: %s",
+		    idfile, duidstr(duid));
+	} else {
+		int hwlen;
+		struct iovec iov[2];
+		union dhcp6opt_duid_type *dp;
+		char tmpbuf[64];	/* HWID should be no more than 64 bytes */
+
+		hwlen = gethwid(tmpbuf, &hwtype);
+		if (hwlen < 0) {
+			bb_error_msg("can't get hardware address");
+			goto fail;
+		}
+		duid->dv_buf = xmalloc(hwlen + sizeof(union dhcp6opt_duid_type));
+
+		dp = (union dhcp6opt_duid_type *)duid->dv_buf;
+
+		/* we only support the types 1,3 DUID */
+		switch (duid_type) {
+			case 1: {
+				uint64_t t64;
+
+				len = sizeof(struct dhcp6opt_duid_type1);
+				dp->d1.hwtype = htons(hwtype);
+				/* time is Jan 1, 2000 (UTC), modulo 2^32 */
+				t64 = (uint64_t)(time(NULL) - 946684800);
+				dp->d1.time = htonl((uint32_t )t64);
+				break;
+				}
+			case 3:
+				len = sizeof(struct dhcp6opt_duid_type3);
+				dp->d3.hwtype = htons(hwtype);
+				break;
+		}
+		dp->type = htons(duid_type);
+		memcpy((char *)dp + len, tmpbuf, hwlen);
+		len += hwlen;
+		duid->dv_len = len;
+
+		log1("generated a new DUID: %s", duidstr(duid));
+
+		/* save the (new) ID to the file for next time */
+		fd = open(idfile, O_WRONLY|O_CREAT|O_TRUNC);
+		if (fd < 0) {
+			/* Not fatal */
+			return 0;
+		}
+		iov[0].iov_base = &len;
+		iov[0].iov_len  = sizeof(len);
+		iov[1].iov_base = duid->dv_buf;
+		iov[1].iov_len  = duid->dv_len;
+		if (writev(fd, iov, 2) < 0) {
+			bb_error_msg("can't write DUID file");
+			goto fail;
+		}
+	}
+	if (fd > 0)
+		close(fd);
+	return 0;
+
+  fail:
+	if (fd > 0)
+		close(fd);
+	dhcp6_vbuf_free(duid);
+	return -1;
+}
+
+void dhcp6_init_options(struct dhcp6_optinfo *optinfo)
+{
+	memset(optinfo, 0, sizeof(*optinfo));
+
+	optinfo->pref = -1;
+	optinfo->elapsed_time = -1;
+	optinfo->refreshtime = -1;
+
+	TAILQ_INIT(&optinfo->ia_list);
+	TAILQ_INIT(&optinfo->reqopt_list);
+	TAILQ_INIT(&optinfo->stcode_list);
+	TAILQ_INIT(&optinfo->ad_list);
+
+	optinfo->authproto = -1;
+	optinfo->authalgorithm = -1;
+	optinfo->authrdm = -1;
+}
+
+void dhcp6_clear_options(struct dhcp6_optinfo *optinfo)
+{
+	switch (optinfo->authproto) {
+	case DHCP6_AUTHPROTO_DELAYED:
+		dhcp6_vbuf_free(&optinfo->authinfo.aiu_delayed.realm);
+		break;
+	}
+
+	dhcp6_vbuf_free(&optinfo->clientID);
+	dhcp6_vbuf_free(&optinfo->serverID);
+
+	dhcp6_clear_list(&optinfo->ia_list);
+	dhcp6_clear_list(&optinfo->reqopt_list);
+	dhcp6_clear_list(&optinfo->stcode_list);
+	dhcp6_clear_list(&optinfo->ad_list);
+
+	dhcp6_vbuf_free(&optinfo->relay_msg);
+	dhcp6_vbuf_free(&optinfo->ifidopt);
+
+	dhcp6_init_options(optinfo);
+}
+
+void dhcp6_copy_options(struct dhcp6_optinfo *dst, struct dhcp6_optinfo *src)
+{
+	dhcp6_vbuf_copy(&dst->clientID, &src->clientID);
+	dhcp6_vbuf_copy(&dst->serverID, &src->serverID);
+
+	dhcp6_copy_list(&dst->ia_list, &src->ia_list);
+	dhcp6_copy_list(&dst->reqopt_list, &src->reqopt_list);
+	dhcp6_copy_list(&dst->stcode_list, &src->stcode_list);
+	dhcp6_copy_list(&dst->ad_list, &src->ad_list);
+
+	dst->rapidcommit = src->rapidcommit;
+	dst->elapsed_time = src->elapsed_time;
+	dst->refreshtime = src->refreshtime;
+	dst->pref = src->pref;
+
+	if (src->relaymsg_msg != NULL) {
+		dhcp6_vbuf_copy(&dst->relay_msg, &src->relay_msg);
+	}
+
+	if (src->ifidopt_id != NULL) {
+		dhcp6_vbuf_copy(&dst->ifidopt, &src->ifidopt);
+	}
+
+	dst->authflags = src->authflags;
+	dst->authproto = src->authproto;
+	dst->authalgorithm = src->authalgorithm;
+	dst->authrdm = src->authrdm;
+	dst->authrd = src->authrd;
+
+	switch (src->authproto) {
+	case DHCP6_AUTHPROTO_DELAYED:
+		dst->delayedauth_keyid = src->delayedauth_keyid;
+		dst->delayedauth_offset = src->delayedauth_offset;
+		dhcp6_vbuf_copy(&dst->authinfo.aiu_delayed.realm,
+				&src->authinfo.aiu_delayed.realm);
+		break;
+#ifdef notyet
+	case DHCP6_AUTHPROTO_RECONFIG:
+		dst->reconfigauth_type = src->reconfigauth_type;
+		dst->reconfigauth_offset = src->reconfigauth_offset;
+		memcpy(dst->reconfigauth_val, src->reconfigauth_val,
+		    sizeof(dst->reconfigauth_val));
+		break;
+#endif
+	}
+}
+
+static int copy_option(uint16_t type, uint16_t len, void *val,
+		struct dhcp6opt **optp, struct dhcp6opt *ep, int *totallenp)
+{
+	struct dhcp6opt *opt = *optp, opth;
+
+	if ((char *)ep - (char *)opt < len + sizeof(struct dhcp6opt)) {
+		log1("option buffer short for %s", dhcp6optstr(type));
+		return -1;
+	}
+
+	opth.dh6opt_type = htons(type);
+	opth.dh6opt_len = htons(len);
+	memcpy(opt, &opth, sizeof(opth));
+	if (len != 0 && val)
+		memcpy(opt + 1, val, len);
+
+	(*optp) = (struct dhcp6opt *)((char *)(opt + 1) + len);
+	(*totallenp) += sizeof(struct dhcp6opt) + len;
+
+	log2("set %s (len %d)", dhcp6optstr(type), len);
+
+	return 0;
+}
+
+int dhcp6_get_options(struct dhcp6opt *p, struct dhcp6opt *ep,
+			struct dhcp6_optinfo *optinfo)
+{
+	struct dhcp6opt *np;
+	int opt, optlen, tlen;
+	char *cp, *val;
+	union {
+		struct dhcp6opt h;
+		struct dhcp6opt_ia optia;
+	} u ALIGN4;
+	union {
+		uint16_t val16;
+		uint32_t val32;
+		struct dhcp6_ia ia;
+		struct dhcp6_vbuf duid0;
+		struct in6_addr valaddr;
+	} u1 ALIGN4;
+	struct dhcp6_list sublist;
+#if ENABLE_FEATURE_DHCP6_AUTH
+	char *bp = (char *)p;
+	int authinfolen;
+#endif
+
+	TAILQ_INIT(&sublist);
+
+	for (; p + 1 <= ep; p = np) {
+		/*
+		 * get the option header.  XXX: since there is no guarantee
+		 * about the header alignment, we need to make a local copy.
+		 */
+		memcpy(&u.h, p, sizeof(struct dhcp6opt));
+		optlen = ntohs(u.h.dh6opt_len);
+		opt = ntohs(u.h.dh6opt_type);
+
+		cp = (char *)(p + 1);
+		np = (struct dhcp6opt *)(cp + optlen);
+
+		log2("get DHCP6 option %s, len %d", dhcp6optstr(opt), optlen);
+
+		/* option length field overrun */
+		if (opt > D6_OPT__MAX)
+			goto unexpected;
+		tlen = dhcp6_option_typelens[opt].minlen;
+		if (np > ep || optlen < tlen)
+			goto malformed;
+
+		switch (opt) {
+
+		case D6_OPT_CLIENTID:
+			u1.duid0.dv_len = optlen;
+			u1.duid0.dv_buf = cp;
+			log2("  DUID: %s", duidstr(&u1.duid0));
+			dhcp6_vbuf_copy(&optinfo->clientID, &u1.duid0);
+			break;
+
+		case D6_OPT_SERVERID:
+			u1.duid0.dv_len = optlen;
+			u1.duid0.dv_buf = cp;
+			log2("  DUID: %s", duidstr(&u1.duid0));
+			dhcp6_vbuf_copy(&optinfo->serverID, &u1.duid0);
+			break;
+
+		case D6_OPT_STATUS_CODE:
+			move_from_unaligned16(u1.val16, cp);
+			u1.val16 = ntohs(u1.val16);
+			log2("  status code: %s", dhcp6stcodestr(u1.val16));
+
+			/* need to check duplication? */
+			if (dhcp6_add_listval(&optinfo->stcode_list, opt,
+			    DHCP6_LISTVAL_NUM16, &u1, NULL) == NULL) {
+				goto fail;
+			}
+			break;
+
+		case D6_OPT_ORO:
+			if ((optlen & 0x1) != 0) /* must be multiple by sizeof(uint16_t) */
+				goto malformed;
+
+			for (val = cp; val < (char *)np; val += sizeof(uint16_t)) {
+
+				move_from_unaligned16(u1.val16, val);
+				u1.val16 = ntohs(u1.val16);
+				log2("  requested option: %s", dhcp6optstr(u1.val16));
+
+				if (dhcp6_find_listval(&optinfo->reqopt_list,
+				    DHCP6_LISTVAL_NUM16, &u1, 0)) {
+					bb_error_msg("duplicated %s", dhcp6optstr(u1.val16));
+					continue;
+				}
+
+				if (dhcp6_add_listval(&optinfo->reqopt_list, opt,
+				    DHCP6_LISTVAL_NUM16, &u1, NULL) == NULL) {
+					goto fail;
+				}
+			}
+			break;
+
+		case D6_OPT_PREFERENCE:
+			log2("  preference: %d", (int)*(uint8_t *)cp);
+			if (optinfo->pref != -1) {
+				bb_error_msg("duplicated %s", dhcp6optstr(opt));
+			} else
+				optinfo->pref = (int)*(uint8_t *)cp;
+			break;
+
+		case D6_OPT_ELAPSED_TIME:
+			move_from_unaligned16(u1.val16, cp);
+			u1.val16 = ntohs(u1.val16);
+
+			log2("  elapsed time: %u", (uint32_t)u1.val16);
+			if (optinfo->elapsed_time != -1) {
+				bb_error_msg("duplicated %s", dhcp6optstr(opt));
+			} else
+				optinfo->elapsed_time = u1.val16;
+			break;
+
+		case D6_OPT_RELAY_MSG:
+			optinfo->relaymsg_msg = xmemdup(cp, optlen);
+			optinfo->relaymsg_len = optlen;
+			break;
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+		case D6_OPT_AUTH:
+			/*
+			 * Any DHCP message that includes more than one
+			 * authentication option MUST be discarded.
+			 * [RFC3315 Section 21.4.2]
+			 */
+			if (optinfo->authproto != -1) {
+				bb_error_msg("duplicated %s", dhcp6optstr(opt));
+				goto fail;
+			}
+
+			optinfo->authproto = *(uint8_t *)cp++;
+			optinfo->authalgorithm = *(uint8_t *)cp++;
+			optinfo->authrdm = *(uint8_t *)cp++;
+			memcpy(&optinfo->authrd, cp, sizeof(optinfo->authrd));
+			cp += sizeof(optinfo->authrd);
+
+			log2("  %s", sprint_auth(optinfo));
+
+			authinfolen = optlen - tlen;
+			switch (optinfo->authproto) {
+			case DHCP6_AUTHPROTO_DELAYED:
+				if (authinfolen == 0) {
+					optinfo->authflags |= DHCP6OPT_AUTHFLAG_NOINFO;
+					break;
+				}
+				/* XXX: should we reject an empty realm? */
+				if (authinfolen < sizeof(optinfo->delayedauth_keyid) + 16) {
+					goto malformed;
+				}
+
+				optinfo->delayedauth_realmlen = authinfolen -
+				    (sizeof(optinfo->delayedauth_keyid) + 16);
+				optinfo->delayedauth_realmval =
+				    malloc_or_warn(optinfo->delayedauth_realmlen);
+				if (optinfo->delayedauth_realmval == NULL)
+					goto fail;
+				memcpy(optinfo->delayedauth_realmval, cp,
+				    optinfo->delayedauth_realmlen);
+				cp += optinfo->delayedauth_realmlen;
+
+				memcpy(&optinfo->delayedauth_keyid, cp,
+				    sizeof(optinfo->delayedauth_keyid));
+				optinfo->delayedauth_keyid = ntohl(optinfo->delayedauth_keyid);
+				cp += sizeof(optinfo->delayedauth_keyid);
+
+				optinfo->delayedauth_offset = cp - bp;
+				cp += 16;
+
+				log2("  auth key ID: %x, offset=%d, realmlen=%d",
+				    optinfo->delayedauth_keyid,
+				    optinfo->delayedauth_offset,
+				    optinfo->delayedauth_realmlen);
+				break;
+#ifdef notyet
+			case DHCP6_AUTHPROTO_RECONFIG:
+				break;
+#endif
+			default:
+				bb_error_msg("unsupported authentication protocol: %d", *cp);
+				goto fail;
+			}
+			break;
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+		case D6_OPT_RAPID_COMMIT:
+			if (optlen != 0)
+				goto malformed;
+			optinfo->rapidcommit = 1;
+			break;
+
+		case D6_OPT_INTERFACE_ID:
+			optinfo->ifidopt_id = xmemdup(cp, optlen);
+			optinfo->ifidopt_len = optlen;
+			break;
+
+		case D6_OPT_SIP_SERVER_D:
+		case D6_OPT_DNSNAME:
+		case D6_OPT_NIS_DOMAIN:
+		case D6_OPT_NISP_DOMAIN:
+		case D6_OPT_BCMCS_SERVER_D:
+#if ENABLE_FEATURE_UDHCP_RFC3397
+			if (dhcp6_get_domain(optlen, cp, opt, &optinfo->ad_list) == -1)
+				goto fail;
+#endif
+			break;
+
+		case D6_OPT_SIP_SERVER_A:
+		case D6_OPT_DNS:
+		case D6_OPT_NIS_SERVERS:
+		case D6_OPT_NISP_SERVERS:
+		case D6_OPT_BCMCS_SERVER_A:
+		case D6_OPT_SNTP_SERVERS:
+		case D6_OPT_NTP_SERVER:
+			if ((optlen % sizeof(struct in6_addr)) != 0)
+				goto malformed;
+			for (val = cp; val < (char *)np; val += sizeof(struct in6_addr)) {
+				char a[INET6_ADDRSTRLEN];
+
+				memcpy(&u1.valaddr, val, sizeof(struct in6_addr));
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 2
+				sprint_nip6(a, (const uint8_t *)&u1.valaddr);
+				log2("  address: %s", a);
+#endif
+
+				if (dhcp6_find_listval(&optinfo->ad_list, opt, &u1.valaddr,
+					 MATCHLIST_DH6OPTYPE)) {
+					sprint_nip6(a, (const uint8_t *)&u1.valaddr);
+					bb_error_msg("duplicated %s address (%s)",
+								dhcp6optstr(opt), a);
+					continue;
+				}
+
+				if (dhcp6_add_listval(&optinfo->ad_list, opt, DHCP6_LISTVAL_ADDR6,
+					 &u1, NULL) == NULL) {
+					goto fail;
+				}
+			}
+			break;
+
+		case D6_OPT_IA_PD:
+		case D6_OPT_IA_NA:
+			memcpy(((char *)&u) + sizeof(struct dhcp6opt), cp, tlen);
+			u1.ia.iaid = ntohl(u.optia.dh6_iaid);
+			u1.ia.t1 = ntohl(u.optia.dh6_t1);
+			u1.ia.t2 = ntohl(u.optia.dh6_t2);
+
+			log2("  %s: ID=%u, T1=%u, T2=%u", dhcp6optstr(opt),
+				u1.ia.iaid, u1.ia.t1, u1.ia.t2);
+
+			/* duplication check */
+			if (dhcp6_find_listval(&optinfo->ia_list,
+			    opt, &u1, MATCHLIST_DH6OPTYPE)) {
+				bb_error_msg("duplicated %s %u",	dhcp6optstr(opt), u1.ia.iaid);
+				break; /* ignore this IA */
+			}
+
+			/* take care of sub-options */
+			if (copyin_option(opt, (struct dhcp6opt *)(cp + tlen),
+				 (struct dhcp6opt *)(cp + optlen), &sublist)) {
+				goto fail;
+			}
+
+			/* link this option set */
+			if (dhcp6_add_listval(&optinfo->ia_list, opt,
+			    DHCP6_LISTVAL_IA, &u1, &sublist) == NULL) {
+				goto fail;
+			}
+			dhcp6_clear_list(&sublist);
+			break;
+
+		case D6_OPT_REFRESHTIME:
+			move_from_unaligned32(u1.val32, cp);
+			u1.val32 = ntohl(u1.val32);
+			log2("   information refresh time: %u", u1.val32);
+			if (u1.val32 < DHCP6_IRT_MINIMUM) {
+				/*
+				 * A client MUST use the refresh time
+				 * IRT_MINIMUM if it receives the option with a
+				 * value less than IRT_MINIMUM.
+				 * [draft-ietf-dhc-lifetime-02.txt,
+				 *  Section 3.2]
+				 */
+				bb_error_msg("refresh time is too small (%d), adjusted",	u1.val32);
+				u1.val32 = DHCP6_IRT_MINIMUM;
+			}
+			if (optinfo->refreshtime != -1) {
+				bb_error_msg("duplicated %s", dhcp6optstr(opt));
+			} else
+				optinfo->refreshtime = (int64_t)u1.val32;
+			break;
+
+		case D6_OPT_RECONF_ACCEPT:
+			/* Silently ignore unsupported feature */
+			break;
+
+		default:
+ unexpected:
+			/* no option specific behavior */
+			bb_error_msg("unexpected DHCP6 option %s, len %d",
+				dhcp6optstr(opt), optlen);
+			break;
+		}
+	}
+
+	return 0;
+
+ malformed:
+	bb_error_msg("malformed DHCP6 option: type %d, len %d", opt, optlen);
+ fail:
+	dhcp6_clear_list(&sublist);
+	dhcp6_clear_options(optinfo);
+	return -1;
+}
+
+static int copyin_option(int type, struct dhcp6opt *p, struct dhcp6opt *ep,
+			 struct dhcp6_list *list)
+{
+	int opt, optlen, tlen;
+	char *cp;
+	struct dhcp6opt *np;
+	union {
+		struct dhcp6opt h;
+		struct dhcp6opt_stcode stcode;
+		struct dhcp6opt_ia_pd_prefix prefix;
+		struct dhcp6opt_ia_addr addr;
+	} u ALIGN4;
+	union {
+		uint16_t dh6_stcode;
+		struct dhcp6_prefix ia_prefix;
+		struct dhcp6_statefuladdr ia_addr;
+	} u1 ALIGN4;
+	struct dhcp6_list sublist;
+	dhcp6_listval_type_t lvtype;
+	char a[INET6_ADDRSTRLEN];
+
+	TAILQ_INIT(&sublist);
+
+	for (; p + 1 <= ep; p = np) {
+		memcpy(&u.h, p, sizeof(struct dhcp6opt));
+		optlen = ntohs(u.h.dh6opt_len);
+		opt = ntohs(u.h.dh6opt_type);
+
+		cp = (char *)(p + 1);
+		np = (struct dhcp6opt *)(cp + optlen);
+
+		log2("get DHCP6 option %s, len %d", dhcp6optstr(opt), optlen);
+
+		/* check option context & length */
+		switch (opt) {
+		case D6_OPT_IA_PD_PREFIX:
+			if (type != D6_OPT_IA_PD) {
+				bb_error_msg("%s is an invalid position for %s",
+				    dhcp6optstr(type), dhcp6optstr(opt));
+				goto fail;
+			}
+			break;
+		case D6_OPT_IAADDR:
+			if (type != D6_OPT_IA_NA) {
+				bb_error_msg("%s is an invalid position for %s",
+				    dhcp6optstr(type), dhcp6optstr(opt));
+				goto fail;
+			}
+			break;
+		case D6_OPT_STATUS_CODE:
+			break;
+		default:
+			bb_error_msg("unexpected DHCP6 option %s, len %d",
+			    dhcp6optstr(opt), optlen);
+			goto nextoption;
+		} /* switch1(opt) */
+		lvtype = dhcp6_option_typelens[opt].lvtype;
+		tlen = dhcp6_option_typelens[opt].minlen;
+		if (np > ep || optlen < tlen) {
+				bb_error_msg("malformed DHCP6 option: type %d, len %d",
+					opt, optlen);
+				goto fail;
+		}
+		/* copy option main body (fixup unaligned access) */
+		memcpy(((char *)&u) + sizeof(struct dhcp6opt), cp, tlen);
+
+		switch (opt) {
+		case D6_OPT_IA_PD_PREFIX:
+			/* convert option values */
+			u1.ia_prefix.plen = u.prefix.dh6_prefix_len;
+			u1.ia_prefix.pltime = ntohl(u.prefix.dh6_preferred_time);
+			u1.ia_prefix.vltime = ntohl(u.prefix.dh6_valid_time);
+			memcpy(&u1.ia_prefix.addr, &u.prefix.dh6_prefix_addr, sizeof(u1.ia_prefix.addr));
+			if (u1.ia_prefix.plen < 4 || u1.ia_prefix.plen > 128) {
+				bb_error_msg("invalid prefix length: %d", u1.ia_prefix.plen);
+				goto fail;
+			}
+			/* clear padding bits in the prefix address */
+			prefix6_mask(&u1.ia_prefix.addr, u1.ia_prefix.plen);
+
+			sprint_nip6(a, (const uint8_t *)&u1.ia_prefix.addr);
+			log2("  IA_PD prefix: %s/%d pltime=%u vltime=%u", a,
+				u1.ia_prefix.plen, u1.ia_prefix.pltime, u1.ia_prefix.vltime);
+
+			if (dhcp6_find_listval(list, lvtype, &u1, 0)) {
+				bb_error_msg("duplicated IA_PD %s/%d", a, u1.ia_prefix.plen );
+				goto nextoption;
+			}
+
+			/* take care of sub-options */
+			if (copyin_option(opt, (struct dhcp6opt *)(cp + tlen), np,
+				 &sublist)) {
+				goto fail;
+			}
+			break;
+
+		case D6_OPT_IAADDR:
+			/* convert option values */
+			u1.ia_addr.pltime = ntohl(u.addr.dh6_preferred_time);
+			u1.ia_addr.vltime = ntohl(u.addr.dh6_valid_time);
+			memcpy(&u1.ia_addr.addr, &u.addr.dh6_addr, sizeof(u1.ia_addr.addr));
+
+			sprint_nip6(a, (const uint8_t *)&u1.ia_addr.addr);
+			log2("  IA_NA address: %s pltime=%u vltime=%u", a,
+				u1.ia_addr.pltime, u1.ia_addr.vltime);
+
+			if (dhcp6_find_listval(list, lvtype, &u1, 0)) {
+				bb_error_msg("duplicated IA_NA %s", a);
+				goto nextoption;
+			}
+
+			/* take care of sub-options */
+			if (copyin_option(opt, (struct dhcp6opt *)(cp + tlen), np,
+				 &sublist)) {
+				goto fail;
+			}
+			break;
+
+		case D6_OPT_STATUS_CODE:
+			/* convert option values */
+			u1.dh6_stcode = ntohs(u.stcode.dh6_stcode);
+
+			log2("  status code: %s", dhcp6stcodestr(u1.dh6_stcode));
+
+			/* duplication check */
+			if (dhcp6_find_listval(list, lvtype, &u1, 0)) {
+				bb_error_msg("duplicated status code (%d)", u1.dh6_stcode);
+				goto nextoption;
+			}
+			break;
+		} /* switch2(opt) */
+
+		/* copy-in option */
+		if (dhcp6_add_listval(list, opt, lvtype, &u1,
+			 (opt == D6_OPT_STATUS_CODE) ? NULL : &sublist) == NULL)
+			goto fail;
+		dhcp6_clear_list(&sublist);
+
+ nextoption:
+		;
+	} /* for(p) */
+
+	return 0;
+
+ fail:
+	dhcp6_clear_list(&sublist);
+	return -1;
+}
+
+/*
+ * Construct a DHCPv6 option along with sub-options in the wire format.
+ * If the packet buffer is NULL, just calculate the length of the option
+ * (and sub-options) so that the caller can allocate a buffer to store the
+ * option(s).
+ * This function basically assumes that the caller prepares enough buffer to
+ * store all the options.  However, it also takes the buffer end and checks
+ * the possibility of overrun for safety.
+ */
+static int copyout_option(void *p, void *ep, struct dhcp6_listval *optval)
+{
+	union {
+		struct dhcp6opt opt;
+		struct dhcp6opt_stcode stcodeopt;
+		struct dhcp6opt_ia ia;
+		struct dhcp6opt_ia_pd_prefix pd_prefix;
+		struct dhcp6opt_ia_addr ia_addr;
+	} u ALIGN4;
+	void *subp;
+	struct dhcp6_listval *subov;
+	int opt_len, headlen, sublen, opttype;
+
+	/* check invariant for safety */
+	if (ep <= p)
+		return -1;
+
+	/* first, detect the length of the option head */
+	switch (optval->lvtype) {
+	case DHCP6_LISTVAL_IA:
+		headlen = sizeof(u.ia);
+		opttype = optval->dh6optype;
+		break;
+	case DHCP6_LISTVAL_ADDR6:
+		headlen = sizeof(u.pd_prefix);
+		opttype = D6_OPT_IA_PD_PREFIX;
+		break;
+	case DHCP6_LISTVAL_PREFIX6:
+		headlen = sizeof(u.pd_prefix);
+		opttype = D6_OPT_IA_PD_PREFIX;
+		break;
+	case DHCP6_LISTVAL_STATEFULADDR6:
+		headlen = sizeof(u.ia_addr);
+		opttype = D6_OPT_IAADDR;
+		break;
+	case DHCP6_LISTVAL_NUM16:
+		headlen = sizeof(u.stcodeopt);
+		opttype = D6_OPT_STATUS_CODE;
+		break;
+	default:
+		/*
+		 * we encounter an unknown option.  this should be an internal
+		 * error.
+		 */
+		bb_error_msg("unknown listval type %d", optval->lvtype);
+		return -2;
+	}
+
+	/* then, calculate the length of and fill in the sub-options */
+	sublen = 0;
+	subp = p + headlen;
+	TAILQ_FOREACH(subov, &optval->sublist, link) {
+		int s = copyout_option(subp, ep, subov);
+
+		if (s < 0)
+			return s;
+		subp += s;
+		sublen += s;
+	}
+
+	/* finally, deal with the head part again */
+	opt_len = headlen + sublen;
+
+	log2("set %s [lvtype %d] (len %d)", dhcp6optstr(opttype),
+		optval->lvtype, opt_len);
+	if (ep - p < headlen) /* check it just in case */
+		return -1;
+
+	/* fill in the common part */
+	memset(&u, 0, sizeof(u));
+	u.opt.dh6opt_type = htons(opttype);
+	u.opt.dh6opt_len  = htons(opt_len - sizeof(struct dhcp6opt));
+
+	/* fill in type specific fields */
+	switch (optval->lvtype) {
+
+	case DHCP6_LISTVAL_IA:
+		u.ia.dh6_iaid = htonl(optval->val_ia.iaid);
+		u.ia.dh6_t1 = htonl(optval->val_ia.t1);
+		u.ia.dh6_t2 = htonl(optval->val_ia.t2);
+		break;
+
+	case DHCP6_LISTVAL_PREFIX6:
+		u.pd_prefix.dh6_preferred_time = htonl(optval->val_prefix6.pltime);
+		u.pd_prefix.dh6_valid_time = htonl(optval->val_prefix6.vltime);
+		u.pd_prefix.dh6_prefix_len = optval->val_prefix6.plen;
+		/* XXX: prefix_addr is badly aligned, so we need memcpy */
+		memcpy(&u.pd_prefix.dh6_prefix_addr,
+		    &optval->val_prefix6.addr, sizeof(struct in6_addr));
+		break;
+
+	case DHCP6_LISTVAL_STATEFULADDR6:
+		u.ia_addr.dh6_preferred_time = htonl(optval->val_statefuladdr6.pltime);
+		u.ia_addr.dh6_valid_time = htonl(optval->val_statefuladdr6.vltime);
+		u.ia_addr.dh6_addr = optval->val_statefuladdr6.addr;
+		break;
+
+	case DHCP6_LISTVAL_NUM16:
+		u.stcodeopt.dh6_stcode = htons(optval->val_num16);
+		break;
+
+	default:
+		/*
+		 * XXX: this case should be rejected at the beginning of this
+		 * function.
+		 */
+		return -2;
+	}
+	/* copyout the data */
+	memcpy(p, &u, headlen);
+
+	return opt_len;
+}
+
+static int dhcp6_set_iaoptions(int type, struct dhcp6_list *head,
+		struct dhcp6opt **pp, struct dhcp6opt *ep, int *totallenp)
+{
+	struct dhcp6_listval *lv;
+
+	TAILQ_FOREACH(lv, head, link) {
+		int opt_len1;
+
+		if (lv->dh6optype != type)
+			continue;
+
+		opt_len1 = copyout_option(*pp, ep, lv);
+		if (opt_len1 < 0) {
+			bb_error_msg("can't construct an %s option", dhcp6optstr(type));
+			return opt_len1;
+		}
+		(*pp) = (struct dhcp6opt *)((char *)(*pp) + opt_len1);
+		(*totallenp) += opt_len1;
+	}
+	return 0;
+}
+
+static int copyout_reqoptions(int type, struct dhcp6_list *head,
+		struct dhcp6opt **pp, struct dhcp6opt *ep, int *totallenp)
+{
+	struct dhcp6_listval *lv;
+	uint16_t *valp;
+	int opt_len = 0;
+
+	TAILQ_FOREACH(lv, head, link) {
+		opt_len += sizeof(uint16_t);
+	}
+	if (opt_len == 0)
+		return 0;
+
+	valp = (uint16_t *)((char *)(*pp)+ sizeof(struct dhcp6opt));
+	if (ep - (struct dhcp6opt *)valp < opt_len)
+		return -1;
+
+	TAILQ_FOREACH(lv, head, link) {
+		/*
+		 * Information request option can only be specified
+		 * in information-request messages.
+		 * [draft-ietf-dhc-lifetime-02.txt, Section 3.2]
+		 */
+		if (lv->val_num == D6_OPT_REFRESHTIME && type != DH6_INFORM_REQ) {
+			log1("refresh time option is not requested for %s",
+				 dhcp6msgstr(type));
+		}
+
+		move_to_unaligned16(valp++, htons((uint16_t)lv->val_num));
+	}
+	if (copy_option(D6_OPT_ORO, opt_len, NULL, pp, ep, totallenp) != 0) {
+		return -1;
+	}
+
+	return 0;
+}
+
+int dhcp6_set_options(int type, struct dhcp6opt *optbp, struct dhcp6opt *optep,
+		struct dhcp6_optinfo *optinfo)
+{
+	struct dhcp6opt *p = optbp;
+	struct dhcp6_listval *lv;
+	int len = 0;
+
+	if (optinfo->clientID.dv_len) {
+		if (copy_option(D6_OPT_CLIENTID, optinfo->clientID.dv_len,
+		    optinfo->clientID.dv_buf, &p, optep, &len) != 0)
+			goto fail;
+	}
+
+	if (optinfo->serverID.dv_len) {
+		if (copy_option(D6_OPT_SERVERID, optinfo->serverID.dv_len,
+		    optinfo->serverID.dv_buf, &p, optep, &len) != 0)
+			goto fail;
+	}
+
+	if (dhcp6_set_iaoptions(D6_OPT_IA_PD, &optinfo->ia_list, &p, optep, &len) < 0)
+		goto fail;
+
+	if (optinfo->rapidcommit) {
+		if (copy_option(D6_OPT_RAPID_COMMIT, 0, NULL, &p,
+		    optep, &len) != 0)
+			goto fail;
+	}
+
+	if (optinfo->pref != -1) {
+		uint8_t p8 = (uint8_t)optinfo->pref;
+
+		if (copy_option(D6_OPT_PREFERENCE, sizeof(p8), &p8, &p,
+		    optep, &len) != 0)
+			goto fail;
+	}
+
+	if (optinfo->elapsed_time != -1) {
+		uint16_t p16 = htons((uint16_t)optinfo->elapsed_time);
+
+		if (copy_option(D6_OPT_ELAPSED_TIME, sizeof(p16), &p16, &p,
+		    optep, &len) != 0)
+			goto fail;
+	}
+
+	TAILQ_FOREACH(lv, &optinfo->stcode_list, link) {
+		uint16_t code = htons(lv->val_num16);
+
+		if (copy_option(D6_OPT_STATUS_CODE, sizeof(code), &code, &p,
+		    optep, &len) != 0)
+			goto fail;
+	}
+
+	if (!TAILQ_EMPTY(&optinfo->reqopt_list)) {
+		if (copyout_reqoptions(type, &optinfo->reqopt_list, &p,
+		    optep, &len) != 0)
+			goto fail;
+	}
+
+	if (dhcp6_set_iaoptions(D6_OPT_IA_NA, &optinfo->ia_list, &p, optep, &len) < 0)
+		goto fail;
+
+	if (optinfo->relaymsg_len) {
+		if (copy_option(D6_OPT_RELAY_MSG, optinfo->relaymsg_len,
+		    optinfo->relaymsg_msg, &p, optep, &len) != 0)
+			goto fail;
+	}
+
+	if (optinfo->ifidopt_id) {
+		if (copy_option(D6_OPT_INTERFACE_ID, optinfo->ifidopt_len,
+		    optinfo->ifidopt_id, &p, optep, &len) != 0)
+			goto fail;
+	}
+
+	if (optinfo->refreshtime != -1) {
+		uint32_t p32 = htonl((uint32_t)optinfo->refreshtime);
+
+		if (copy_option(D6_OPT_REFRESHTIME, sizeof(p32), &p32, &p,
+		    optep, &len) != 0)
+			goto fail;
+	}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	if (optinfo->authproto != -1) {
+		if (copyout_auth(optinfo, &p, optbp, optep, &len) != 0)
+			goto fail;
+	}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+	return len;
+
+  fail:
+	return -1;
+}
+
+/* timer parameters (msec, unless explicitly commented) */
+void dhcp6_set_timeoparam(struct dhcp6_event *ev)
+{
+	ev->retrans = 0;
+	ev->max_retrans_cnt = 0;
+	ev->max_retrans_dur = 0;
+	ev->max_retrans_time = 0;
+
+	switch (ev->state) {
+	case DHCP6S_SOLICIT:
+		ev->init_retrans = 1000;
+		ev->max_retrans_time = 120000;
+		break;
+	case DHCP6S_INFOREQ:
+		ev->init_retrans = 1000;
+		ev->max_retrans_time = 120000;
+		break;
+	case DHCP6S_REQUEST:
+		ev->init_retrans = 1000;
+		ev->max_retrans_time = 30000;
+		ev->max_retrans_cnt = 10;	/* Max Request retry attempts */
+		break;
+	case DHCP6S_RENEW:
+		ev->init_retrans = 10000;	/* 10secs */
+		ev->max_retrans_time = 600000;	/* 600secs */
+		break;
+	case DHCP6S_REBIND:
+		ev->init_retrans = 10000;	/* 10secs */
+		ev->max_retrans_time = 600000;	/* 600secs */
+		break;
+	case DHCP6S_RELEASE:
+		ev->init_retrans = 1000;
+		ev->max_retrans_cnt = 5;
+		break;
+	default:
+		bb_error_msg_and_die("unexpected event state %d on %s",
+		    ev->state, ev->ifp->ifname);
+	}
+}
+
+void dhcp6_reset_timer(struct dhcp6_event *ev)
+{
+	double n, r;
+
+	switch (ev->state) {
+	case DHCP6S_INIT:
+		/*
+		 * The first Solicit message from the client on the interface
+		 * MUST be delayed by a random amount of time between
+		 * 0 and SOL_MAX_DELAY.
+		 * [RFC3315 17.1.2]
+		 * XXX: a random delay is also necessary before the first
+		 * information-request message.  Fortunately, the parameters
+		 * and the algorithm for these two cases are the same.
+		 * [RFC3315 18.1.5]
+		 */
+		ev->retrans = (random() % (SOL_MAX_DELAY));
+		break;
+
+	default:
+		if (ev->state == DHCP6S_SOLICIT && ev->timeouts == 0) {
+			/*
+			 * The first RT MUST be selected to be strictly
+			 * greater than IRT by choosing RAND to be strictly
+			 * greater than 0.
+			 * [RFC3315 17.1.2]
+			 */
+			r = (double)((random() % 1000) + 1) / 10000;
+			n = ev->init_retrans + r * ev->init_retrans;
+		} else {
+			r = (double)((random() % 2000) - 1000) / 10000;
+
+			if (ev->timeouts == 0) {
+				n = ev->init_retrans + r * ev->init_retrans;
+			} else {
+				n = 2 * ev->retrans + r * ev->retrans;
+			}
+		}
+		if (ev->max_retrans_time && n > ev->max_retrans_time)
+			n = ev->max_retrans_time + r * ev->max_retrans_time;
+
+		ev->retrans = (long)n;
+		break;
+	}
+
+	dhcp6_timer_set(ev->retrans, ev->timer);
+
+	log1("reset a timer on %s, state=%s, timeo=%d, retrans=%ld",
+		ev->ifp->ifname, dhcp6_event_statestr(ev), ev->timeouts, ev->retrans);
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+/*
+ * Provide an NTP-format timestamp as a replay detection counter
+ * as mentioned in RFC3315.
+ */
+#define JAN_1970        2208988800UL        /* 1970 - 1900 in seconds */
+int get_rdvalue(int rdm, void *rdvalue)
+{
+	struct timeval tv;
+	uint32_t pack[2];
+
+	if (rdm != DHCP6_AUTHRDM_MONOCOUNTER) {
+		bb_error_msg("unsupported replay detection method (%d)", rdm);
+		return -1;
+	}
+
+	gettimeofday(&tv, NULL);
+
+	pack[0] = htonl((uint32_t)tv.tv_sec + JAN_1970);
+	pack[1] = htonl((uint32_t)tv.tv_usec);
+
+	memcpy(rdvalue, pack, sizeof(uint64_t));
+
+	return 0;
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+# if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 2
+static char *sprint_auth(struct dhcp6_optinfo *optinfo)
+{
+	char *ret;
+	const char *proto, *alg, *rdm;
+	char proto0[16], alg0[16], rdm0[16];
+
+	switch (optinfo->authproto) {
+	case DHCP6_AUTHPROTO_DELAYED:
+		proto = "delayed";
+		break;
+#ifdef notyet
+	case DHCP6_AUTHPROTO_RECONFIG:
+		proto = "reconfig";
+		break;
+#endif
+	default:
+		snprintf(proto0, sizeof(proto0), "unknown(%d)",
+		    optinfo->authproto & 0xff);
+		proto = proto0;
+		break;
+	}
+
+	switch (optinfo->authalgorithm) {
+	case DHCP6_AUTHALG_HMACMD5:
+		alg = "HMAC-MD5";
+		break;
+	default:
+		snprintf(alg0, sizeof(alg0), "unknown(%d)",
+		    optinfo->authalgorithm & 0xff);
+		alg = alg0;
+		break;
+	}
+
+	switch (optinfo->authrdm) {
+	case DHCP6_AUTHRDM_MONOCOUNTER:
+		rdm = "mono counter";
+		break;
+	default:
+		snprintf(rdm0, sizeof(rdm0), "unknown(%d)", optinfo->authrdm);
+		rdm = rdm0;
+	}
+
+	ret = xasprintf("proto: %s, alg: %s, RDM: %s, RD: %llx",
+	    proto, alg, rdm, SWAP_BE64(optinfo->authrd));
+
+	return ret;
+}
+# endif /* CONFIG_UDHCP_DEBUG */
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+static const char *dh6_opts_strings[D6_OPT__MAX+1] = {
+ [D6_OPT_CLIENTID]			= "client ID",
+ [D6_OPT_SERVERID]			= "server ID",
+ [D6_OPT_IA_NA]				= "identity association",
+ [D6_OPT_IA_TA]				= "IA for temporary",
+ [D6_OPT_IAADDR]			= "IA address",
+ [D6_OPT_ORO]				= "option request",
+ [D6_OPT_PREFERENCE]		= "preference",
+ [D6_OPT_ELAPSED_TIME]		= "elapsed time",
+ [D6_OPT_RELAY_MSG]			= "relay message",
+ [D6_OPT_AUTH]				= "authentication",
+ [D6_OPT_UNICAST]			= "server unicast",
+ [D6_OPT_STATUS_CODE]		= "status code",
+ [D6_OPT_RAPID_COMMIT]		= "rapid commit",
+ [D6_OPT_USER_CLASS]		= "user class",
+ [D6_OPT_VENDOR_CLASS]		= "vendor class",
+ [D6_OPT_VENDOR_OPTS]		= "vendor specific info",
+ [D6_OPT_INTERFACE_ID]		= "interface ID",
+ [D6_OPT_RECONF_MSG]		= "reconfigure message",
+ [D6_OPT_RECONF_ACCEPT]		= "reconfigure accept",
+ [D6_OPT_SIP_SERVER_D]		= "SIP domain name",
+ [D6_OPT_SIP_SERVER_A]		= "SIP server address",
+ [D6_OPT_DNS]				= "DNS",
+ [D6_OPT_DNSNAME]			= "domain search list",
+ [D6_OPT_IA_PD]				= "IA_PD",
+ [D6_OPT_IA_PD_PREFIX]		= "IA_PD prefix",
+ [D6_OPT_NIS_SERVERS]		= "NIS servers",
+ [D6_OPT_NISP_SERVERS]		= "NIS+ servers",
+ [D6_OPT_NIS_DOMAIN]		= "NIS domain name",
+ [D6_OPT_NISP_DOMAIN]		= "NIS+ domain name",
+ [D6_OPT_SNTP_SERVERS]		= "SNTP server",
+ [D6_OPT_REFRESHTIME]		= "information refresh time",
+ [D6_OPT_BCMCS_SERVER_D]	= "BCMCS domain name",
+ [D6_OPT_BCMCS_SERVER_A]	= "BCMCS server address",
+ [D6_OPT_REMOTE_ID]			= "remote ID",
+ [D6_OPT_SUBSCRIBER_ID]		= "subscriber ID",
+ [D6_OPT_ERO]				= "Relay agent echo request",
+ [D6_OPT_NTP_SERVER]		= "NTP server",
+};
+
+#define genstr        (&bb_common_bufsiz1[COMMON_BUFSIZE / 2])
+#define sizeof_genstr (COMMON_BUFSIZE / 2 - 1)
+const char *dhcp6optstr(int type)
+{
+	if (type > 65535)
+		return "INVALID option";
+	if (type > D6_OPT__MAX || dh6_opts_strings[type] == NULL)
+		return utoa_to_buf(type, genstr, sizeof_genstr);
+
+	return dh6_opts_strings[type];
+}
+
+static const char *dh6_msgs_strings[DH6__MSG__MAX+1] = {
+ [0]				= "???",
+ [DH6_SOLICIT]		= "solicit",
+ [DH6_ADVERTISE]	= "advertise",
+ [DH6_REQUEST]		= "request",
+ [DH6_CONFIRM]		= "confirm",
+ [DH6_RENEW]		= "renew",
+ [DH6_REBIND]		= "rebind",
+ [DH6_REPLY]		= "reply",
+ [DH6_RELEASE]		= "release",
+ [DH6_DECLINE]		= "decline",
+ [DH6_RECONFIGURE]	= "reconfigure",
+ [DH6_INFORM_REQ]	= "information request",
+ [DH6_RELAY_FORW]	= "relay-forward",
+ [DH6_RELAY_REPLY]	= "relay-reply",
+};
+
+const char *dhcp6msgstr(int type)
+{
+	if (type > 255)
+		return "INVALID msg";
+	if (type > DH6__MSG__MAX) {
+		return utoa_to_buf(type, genstr+16, sizeof_genstr-16);
+	}
+
+	return dh6_msgs_strings[type];
+}
+
+static const char *dh6_stcodes_strings[D6_OPT_STCODE__MAX+1] = {
+ [D6_OPT_STCODE_SUCCESS]		= "success",
+ [D6_OPT_STCODE_UNSPECFAIL]		= "unspec failure",
+ [D6_OPT_STCODE_NOADDRSAVAIL]	= "no addresses",
+ [D6_OPT_STCODE_NOBINDING]		= "no binding",
+ [D6_OPT_STCODE_NOTONLINK]		= "not on-link",
+ [D6_OPT_STCODE_USEMULTICAST]	= "use multicast",
+ [D6_OPT_STCODE_NOPREFIXAVAIL]	= "no prefixes",
+};
+
+const char *dhcp6stcodestr(uint16_t code)
+{
+	if (code > 255)
+		return "INVALID code";
+	if (code > D6_OPT_STCODE__MAX) {
+		return utoa_to_buf(code, genstr+32, sizeof_genstr-32);
+	}
+
+	return dh6_stcodes_strings[code];
+}
+
+void BUG_dhcp6c_globals_too_big(void);
+
+char *duidstr(struct dhcp6_vbuf *duid)
+{
+	int i, len = 0;
+#define	duid_buf	(genstr + 48)
+	if (sizeof("xx:") * 32 + sizeof("...") > sizeof_genstr - 48)
+		BUG_dhcp6c_globals_too_big();
+
+	for (i = 0; i < duid->dv_len && i < 32; i++) {
+		if (i > 0)
+			duid_buf[len++] = ':';
+		bin2hex(duid_buf + len, (const char * )&duid->dv_buf[i], 1);
+		len += 2;
+	}
+	if (i < duid->dv_len) {
+		strcpy(duid_buf + len, "...");
+		len += 3;
+	}
+	duid_buf[len] = '\0';
+
+	return duid_buf;
+#undef  duid_buf
+}
+#undef	genstr
+#undef	sizeof_genstr
+
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+const char *dhcp6_event_statestr(struct dhcp6_event *ev)
+{
+	switch (ev->state) {
+	case DHCP6S_INIT:
+		return "INIT";
+	case DHCP6S_SOLICIT:
+		return "SOLICIT";
+	case DHCP6S_INFOREQ:
+		return "INFOREQ";
+	case DHCP6S_REQUEST:
+		return "REQUEST";
+	case DHCP6S_RENEW:
+		return "RENEW";
+	case DHCP6S_REBIND:
+		return "REBIND";
+	case DHCP6S_RELEASE:
+		return "RELEASE";
+	default:
+		return "???"; /* XXX */
+	}
+}
+#endif
diff -urN busybox-1.36.1-ref/networking/udhcp/dhcp6c_config.c busybox-1.36.1/networking/udhcp/dhcp6c_config.c
--- busybox-1.36.1-ref/networking/udhcp/dhcp6c_config.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.36.1/networking/udhcp/dhcp6c_config.c	2023-05-19 23:01:27.861391752 +0300
@@ -0,0 +1,1437 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2002 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <net/if.h>
+
+#include "dhcp6c.h"
+#include "dhcp6c_auth.h"
+
+/* structures and definitions used in the config file parser */
+struct cf_list {
+	struct cf_list *next;
+	struct cf_list *tail;
+
+	int type;
+	int line;		/* the line number of the config file */
+
+	/* type dependent values: */
+	char *ptr;
+	struct cf_list *sublist;
+};
+#define MAKE_CFLIST(l, t, pp, pl) do { \
+	(l) = (struct cf_list *)xzalloc(sizeof(*(l))); \
+	l->line = lineno; \
+	l->type = (t); \
+	l->ptr  = (pp); \
+	l->sublist = (pl); \
+	l->tail = (l); \
+	} while (0)
+
+static void cleanup_cflist(struct cf_list *);
+
+
+/* DHCPv6 authentication information */
+struct authinfo {
+	struct authinfo *next;
+
+	char *name;		/* auth info name */
+
+	int protocol;	/* authentication protocol */
+	int algorithm;	/* authentication algorithm */
+	int rdm;		/* random attack detection method */
+
+	/* keys specific to this info? */
+};
+
+static int add_pd_pif(struct ia_conf *, struct cf_list *);
+static int add_options(int, struct dhcp6_if *, struct cf_list *);
+static int add_prefix6(struct dhcp6_list *, int type, int lvtype,
+						struct dhcp6_prefix *);
+static void clear_pd_pif(struct ia_conf *);
+static void clear_iaconf(struct ia_conflist *);
+#if ENABLE_FEATURE_DHCP6_AUTH
+static void clear_keys(struct keyinfo *);
+static void clear_authinfo(struct authinfo *);
+#endif
+static int get_default_ifid(struct prefix_ifconf *);
+static char* FAST_FUNC qstrdup(char *);
+
+
+static int configure_interface(void)
+{
+	struct cf_list *cnl;
+	struct dhcp6_if *ifp = &client6_config.dhcp6c_if;
+
+	for (cnl = client6_config.config_list; cnl; cnl = cnl->next) {
+		struct cf_list *cfl;
+
+		if (cnl->type != DECL_IFACE)
+			continue;
+		log3("configure iface '%s'", cnl->ptr);
+
+		if (if_nametoindex(cnl->ptr) == 0) {
+			bb_perror_msg("%s:%d invalid interface(%s)",
+				client6_config.conffile, cnl->line,	cnl->ptr);
+			return -1;
+		}
+
+		if (strcmp(ifp->ifname, cnl->ptr) != 0) {
+			log1("Unknown interface(%s), ignoring", cnl->ptr);
+			continue;
+		}
+
+		ifp->server_pref = -1;
+
+		for (cfl = cnl->sublist; cfl; cfl = cfl->next) {
+			switch (cfl->type) {
+			case DECL_REQUEST:
+			case DECL_SEND:
+				if (add_options(cfl->type, ifp, cfl->sublist))
+					return -1;
+				break;
+			case DECL_INFO_ONLY:
+				ifp->send_flags |= DHCIFF_INFO_ONLY;
+				break;
+			case DECL_SCRIPT:
+				if (ifp->scriptpath) {
+					bb_error_msg("%s:%d duplicated script",
+					    client6_config.conffile, cfl->line);
+					return -1;
+				}
+				ifp->scriptpath = qstrdup(cfl->ptr);
+				if (ifp->scriptpath == NULL)
+					goto bad;
+				if (ifp->scriptpath[0] != '/') {
+					bb_error_msg("script must be an absolute path");
+					return -1;
+				}
+				break;
+			default:
+ bad:
+				bb_error_msg("%s:%d invalid configuration",
+							client6_config.conffile, cfl->line);
+				return -1;
+			}
+		} /* for(cnl->sublist) */
+	} /* for(cf_list) */
+
+	return 0;
+}
+
+static int configure_ia(void)
+{
+	struct cf_list *iap;
+	struct ia_conf *iac = NULL;
+
+	for (iap = client6_config.config_list; iap; iap = iap->next) {
+		struct cf_list *cfl;
+
+		if (iap->type != DHCPOPT_IA_PD && iap->type != DHCPOPT_IA_NA)
+			continue;
+		log3("configure %s '%s'", dhcp6optstr(iap->type), iap->ptr);
+
+		iac = xzalloc(sizeof(struct ia_conf));
+		/* common initialization */
+		iac->type = iap->type;
+		iac->iaid = (uint32_t)atoi(iap->ptr);
+		TAILQ_INIT(&iac->iadata);
+		TAILQ_INSERT_TAIL(&client6_config.ia_allconflist, iac, link);
+
+		/* IA-type specific initialization */
+		switch (iap->type) {
+		case DHCPOPT_IA_PD:
+			TAILQ_INIT(&iac->iapd_pif_list);
+			/* Fall through */
+		case DHCPOPT_IA_NA:
+			TAILQ_INIT(&iac->prefix_list);
+			break;
+		default:
+			/* not happen - for compiler only*/
+			break;
+		}
+
+		/* set up parameters for the IA */
+		for (cfl = iap->sublist; cfl; cfl = cfl->next) {
+
+			switch (iap->type) {
+			case DHCPOPT_IA_PD:
+				switch (cfl->type) {
+				case IACONF_PIF:
+					if (add_pd_pif(iac, cfl))
+						return -1;
+					break;
+				case IACONF_PREFIX:
+					if (add_prefix6(&iac->prefix_list, iap->type,
+						 DHCP6_LISTVAL_PREFIX6,
+						 (struct dhcp6_prefix *)cfl->ptr))
+						return -1;
+					break;
+				default:
+					goto bad;
+				}
+				break;
+			case DHCPOPT_IA_NA:
+				switch (cfl->type) {
+				case IACONF_ADDR:
+					if (add_prefix6(&iac->prefix_list, iap->type,
+						 DHCP6_LISTVAL_STATEFULADDR6,
+						 (struct dhcp6_prefix *)cfl->ptr))
+						return -1;
+					break;
+				default:
+					goto bad;
+				}
+				break;
+			default:
+				/* not happen - for compiler only*/
+ bad:
+				bb_error_msg("%s:%d invalid configuration",
+					    client6_config.conffile, cfl->line);
+				return -1;
+			}
+		} /* for(iap->sublist) */
+	} /* for(cf_list) */
+
+	return 0;
+}
+
+static int add_pd_pif(struct ia_conf *iac, struct cf_list *cfl0)
+{
+	struct cf_list *cfl;
+	struct prefix_ifconf *pif;
+
+	/* duplication check */
+	TAILQ_FOREACH(pif, &iac->iapd_pif_list, link) {
+		if (strcmp(pif->ifname, cfl0->ptr) == 0) {
+			bb_error_msg("%s:%d duplicated prefix interface %s",
+			    client6_config.conffile, cfl0->line, cfl0->ptr);
+			return 0; /* ignore it */
+		}
+	}
+
+	pif = xzalloc(sizeof(*pif));
+
+	/* validate and copy ifname */
+	if (if_nametoindex(cfl0->ptr) == 0) {
+		bb_perror_msg("%s:%d invalid interface(%s)",
+		    client6_config.conffile, cfl0->line, cfl0->ptr);
+		goto bad;
+	}
+	pif->ifname = xstrdup(cfl0->ptr);
+
+	pif->ifid_len = IFID_LEN_DEFAULT;
+	pif->sla_len = SLA_LEN_DEFAULT;
+	if (get_default_ifid(pif)) {
+		bb_error_msg("can't get IF ID for %s", pif->ifname);
+		goto bad;
+	}
+
+	for (cfl = cfl0->sublist; cfl; cfl = cfl->next) {
+		switch (cfl->type) {
+		case IFPARAM_SLA_ID:
+			pif->sla_id = xatou32(cfl->ptr);
+			break;
+		case IFPARAM_SLA_LEN:
+			pif->sla_len = xatou(cfl->ptr);
+			if (pif->sla_len < 0 || pif->sla_len > 128) {
+				bb_error_msg("%s:%d invalid SLA length: %d",
+				    client6_config.conffile, cfl->line, pif->sla_len);
+				goto bad;
+			}
+			break;
+		default:
+			bb_error_msg("%s:%d invalid configuration",
+			    client6_config.conffile, cfl->line);
+			goto bad;
+		}
+	}
+
+	TAILQ_INSERT_TAIL(&iac->iapd_pif_list, pif, link);
+	return 0;
+
+ bad:
+	free(pif->ifname);
+	free(pif);
+	return -1;
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int configure_keys(void)
+{
+	struct cf_list *key;
+	struct keyinfo *kinfo;
+	char *expire = NULL;
+
+	for (key = client6_config.config_list; key; key = key->next) {
+		struct cf_list *cfl;
+
+		if (key->type != DECL_KEYINFO)
+			continue;
+		log3("configure keys '%s'", key->ptr);
+
+		kinfo = xzalloc(sizeof(*kinfo));
+		kinfo->next = client6_config.key_list;
+		kinfo->name = xstrdup(key->ptr);
+		kinfo->keyid = -1;
+		client6_config.key_list = kinfo;
+
+		for (cfl = key->sublist; cfl; cfl = cfl->next) {
+			switch (cfl->type) {
+			case KEYPARAM_REALM:
+				if (kinfo->realm.dv_buf != NULL) {
+					bb_error_msg("%s:%d duplicated %s for key %s (ignored)",
+						client6_config.conffile, cfl->line, "realm", key->ptr);
+					continue;
+				}
+				kinfo->realm.dv_buf = qstrdup(cfl->ptr);
+				if (kinfo->realm.dv_buf == NULL)
+					goto wrong;
+				kinfo->realm.dv_len = strlen(kinfo->realm.dv_buf);
+				break;
+			case KEYPARAM_KEYID:
+				if (kinfo->keyid != -1) {
+					bb_error_msg("%s:%d duplicated %s for key %s (ignored)",
+						client6_config.conffile, cfl->line, "key ID", key->ptr);
+					continue;
+				}
+				kinfo->keyid = xatou32(cfl->ptr);
+				break;
+			case KEYPARAM_SECRET:
+				/* duplicate check */
+				if (kinfo->secret != NULL) {
+					bb_error_msg("%s:%d duplicated %s for key %s (ignored)",
+						client6_config.conffile, cfl->line, "secret", key->ptr);
+					continue; /* ignored */
+				}
+
+				{
+					int len;
+					unsigned char *out_tail;
+					const char *in_tail;
+
+					/* convert base64 string to binary secret */
+					len = strlen(cfl->ptr);
+					len = (len >> 2) + (len >> 1) + 1; /* 3/4x + 1 */
+					kinfo->secret = xmalloc(len);
+					out_tail = kinfo->secret;
+					in_tail = decode_base64((char **)&out_tail, cfl->ptr);
+					if (*in_tail != '\0') {
+						free(kinfo->secret);
+						goto wrong;
+					}
+					kinfo->secretlen = out_tail - kinfo->secret;
+				}
+				break;
+			case KEYPARAM_EXPIRE:
+				if (expire != NULL) {
+					bb_error_msg("%s:%d duplicated %s for key %s (ignored)",
+						client6_config.conffile, cfl->line, "expire", key->ptr);
+					continue;
+				}
+				expire = qstrdup(cfl->ptr);
+				if (expire == NULL)
+					goto wrong;
+				break;
+			default:
+ wrong:
+				bb_error_msg("%s:%d invalid parameter for %s",
+				    client6_config.conffile, cfl->line, key->ptr);
+				goto bad;
+			}
+		} /* for(key->sublist) */
+
+		/* check for mandatory parameters or use default */
+		if (kinfo->realm.dv_buf == NULL) {
+			bb_error_msg("%s not specified for key %s",	"realm", key->ptr);
+			goto bad;
+		}
+		if (kinfo->keyid == -1) {
+			bb_error_msg("%s not specified for key %s",	"key ID", key->ptr);
+			goto bad;
+		}
+		if (kinfo->secret == NULL) {
+			bb_error_msg("%s not specified for key %s",	"secret", key->ptr);
+			goto bad;
+		}
+		if (expire != NULL) {
+			if (strcmp(expire, "forever") != 0) {
+				time_t now, expire_time;
+				struct tm lt;
+
+				time(&now);
+				parse_datestr(expire, &lt);
+				expire_time = mktime(&lt);
+				if (expire_time < now) {
+					bb_error_msg("past expiration time specified: %s",
+					    expire);
+					goto bad;
+				}
+
+				kinfo->expire = expire_time;
+			}
+		}
+	} /* for(cf_list) */
+
+	return 0;
+
+ bad:
+	free(expire);
+	return -1;
+}
+
+static int configure_authinfo(void)
+{
+	struct cf_list *auth;
+	struct authinfo *ainfo;
+
+	for (auth = client6_config.config_list; auth; auth = auth->next) {
+		struct cf_list *cfl;
+
+		if (auth->type != DECL_AUTHINFO)
+			continue;
+		log3("configure auth '%s'", auth->ptr);
+
+		ainfo = xzalloc(sizeof(*ainfo));
+		ainfo->next = client6_config.auth_list;
+		client6_config.auth_list = ainfo;
+		ainfo->protocol = -1;
+		ainfo->algorithm = -1;
+		ainfo->rdm = -1;
+		ainfo->name = xstrdup(auth->ptr);
+
+		for (cfl = auth->sublist; cfl; cfl = cfl->next) {
+			switch (cfl->type) {
+			case AUTHPARAM_PROTO:
+				if (ainfo->protocol != -1) {
+					bb_error_msg("%s:%d duplicated %s for auth %s (ignored)",
+					    client6_config.conffile, cfl->line,
+					    "protocol", auth->ptr);
+					continue; /* ignored */
+				}
+				if (strcasecmp(cfl->ptr, "delayed") == 0)
+					ainfo->protocol = DHCP6_AUTHPROTO_DELAYED;
+#if 0 /* ENABLE_DHCP6S */
+				else if (strcasecmp(cfl->ptr, "reconfig") == 0)
+					ainfo->protocol = DHCP6_AUTHPROTO_RECONFIG;
+#endif
+				else
+					goto wrong;
+				break;
+			case AUTHPARAM_ALG:
+				if (ainfo->algorithm != -1) {
+					bb_error_msg("%s:%d duplicated %s for auth %s (ignored)",
+					    client6_config.conffile, cfl->line,
+					    "algorithm", auth->ptr);
+					continue; /* ignored */
+				}
+				if (strcasecmp(cfl->ptr, "hmac-md5") == 0 ||
+				    strcasecmp(cfl->ptr, "hmacmd5") == 0)
+					ainfo->algorithm = DHCP6_AUTHALG_HMACMD5;
+				else
+					goto wrong;
+				break;
+			case AUTHPARAM_RDM:
+				if (ainfo->rdm != -1) {
+					bb_error_msg("%s:%d duplicated %s for auth %s (ignored)",
+					    client6_config.conffile, cfl->line,
+					    "RDM", auth->ptr);
+					continue; /* ignored */
+				}
+				if (strcasecmp(cfl->ptr, "monocounter") == 0)
+					ainfo->rdm = DHCP6_AUTHRDM_MONOCOUNTER;
+				else
+					goto wrong;
+				break;
+			case AUTHPARAM_KEY:
+				bb_error_msg("%s:%d auth info specific keys "
+				    "are not supported",
+				    client6_config.conffile, cfl->line);
+				break;
+			default:
+ wrong:
+				bb_error_msg("%s:%d invalid auth info parameter for %s",
+				    client6_config.conffile, cfl->line, auth->ptr);
+				goto bad;
+			}
+		} /* for(auth->sublist) */
+
+		/* check for mandatory parameters and consistency */
+		switch (ainfo->protocol) {
+		case -1:
+			bb_error_msg("auth protocol not specified for %s", auth->ptr);
+			goto bad;
+		case DHCP6_AUTHPROTO_DELAYED:
+			break;
+		case DHCP6_AUTHPROTO_RECONFIG:
+			goto bad;
+			break;
+		}
+		if (ainfo->algorithm == -1)
+			ainfo->algorithm = DHCP6_AUTHALG_HMACMD5;
+		if (ainfo->rdm == -1)
+			ainfo->rdm = DHCP6_AUTHRDM_MONOCOUNTER;
+	}
+
+	return 0;
+
+ bad:
+	/* there is currently nothing special to recover the error */
+	return -1;
+}
+
+static struct authinfo *find_authinfo(struct authinfo *head, char *name)
+{
+	struct authinfo *ainfo;
+
+	for (ainfo = head; ainfo; ainfo = ainfo->next) {
+		if (strcmp(ainfo->name, name) == 0)
+			return ainfo;
+	}
+
+	return NULL;
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+/* Strip quotes from string */
+static char* FAST_FUNC qstrdup(char *qstr)
+{
+	size_t len;
+	char *dst;
+
+	len = strlen(qstr);
+	if (qstr[0] != '"' || len < 2 || qstr[len - 1] != '"')
+		return NULL;
+
+	dst = xmemdup(qstr + 1, len - 1);
+	dst[len - 2] = '\0';
+
+	return dst;
+}
+
+/* we currently only construct EUI-64 based interface ID */
+static int get_default_ifid(struct prefix_ifconf *pif)
+{
+	uint8_t buf[16];
+
+	if (pif->ifid_len < 64) {
+		bb_error_msg("ID length too short");
+		return -1;
+	}
+
+	/* Such interface must have a mac */
+	if (udhcp_read_interface(pif->ifname, NULL, NULL, buf, NULL))
+		return -2;
+
+	memset(pif->ifid, 0, sizeof(pif->ifid));
+	pif->ifid[8]  = buf[0] ^ 0x02; /* reverse the u/l bit*/
+	pif->ifid[9]  = buf[1];
+	pif->ifid[10] = buf[2];
+	pif->ifid[11] = 0xff;
+	pif->ifid[12] = 0xfe;
+	pif->ifid[13] = buf[3];
+	pif->ifid[14] = buf[4];
+	pif->ifid[15] = buf[5];
+
+	return 0;
+}
+
+void clear_ifconf(int destroy)
+{
+	struct dhcp6_if *ifp = &client6_config.dhcp6c_if;
+
+	ifp->send_flags = 0;
+	ifp->allow_flags = 0;
+
+	ifp->server_pref = -1;
+#if ENABLE_FEATURE_DHCP6_AUTH
+	ifp->authproto = -1;
+	ifp->authalgorithm = -1;
+	ifp->authrdm = -1;
+#endif
+	dhcp6_clear_list(&ifp->reqopt_list);
+
+	clear_iaconf(&ifp->iaconf_list);
+
+	free(ifp->scriptpath);
+	ifp->scriptpath = NULL;
+
+	free(ifp->pool.name);
+	ifp->pool.name = NULL;
+
+	if (ENABLE_FEATURE_CLEAN_UP && destroy) {
+		free(ifp->ifname);
+	}
+}
+
+static void clear_pd_pif(struct ia_conf *iac)
+{
+	struct prefix_ifconf *pif, *pif_next;
+
+	for (pif = TAILQ_FIRST(&iac->iapd_pif_list); pif; pif = pif_next) {
+		pif_next = TAILQ_NEXT(pif, link);
+
+		free(pif->ifname);
+		free(pif);
+	}
+
+	dhcp6_clear_list(&iac->prefix_list);
+}
+
+static void clear_iaconf(struct ia_conflist *ialist)
+{
+	struct ia_conf *iac;
+
+	while ((iac = TAILQ_FIRST(ialist)) != NULL) {
+		TAILQ_REMOVE(ialist, iac, link);
+
+		switch (iac->type) {
+		case DHCPOPT_IA_PD:
+			if (!TAILQ_EMPTY(&iac->iadata)) {
+				bb_error_msg("iadata not empty");
+			}
+			clear_pd_pif(iac);
+			break;
+		case DHCPOPT_IA_NA:
+			break;
+		default:
+			break;
+		}
+		free(iac);
+	}
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static void clear_keys(struct keyinfo *klist)
+{
+	struct keyinfo *key = klist, *key_next;
+
+	while (key) {
+		key_next = key->next;
+
+		free(key->name);
+		dhcp6_vbuf_free(&key->realm);
+		free(key->secret);
+		free(key);
+
+		key = key_next;
+	}
+}
+
+static void clear_authinfo(struct authinfo *alist)
+{
+	struct authinfo *auth = alist, *auth_next;
+
+	while (auth) {
+		auth_next = auth->next;
+		free(auth);
+
+		auth = auth_next;
+	}
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+static int add_options(int opcode, struct dhcp6_if *ifp, struct cf_list *cfl0)
+{
+	struct cf_list *cfl;
+	struct ia_conf *iac;
+	uint32_t iaid;
+#if ENABLE_FEATURE_DHCP6_AUTH
+	struct authinfo *ainfo;
+#endif
+
+	for (cfl = cfl0; cfl; cfl = cfl->next) {
+		switch (cfl->type) {
+		case DHCPOPT_RAPID_COMMIT:
+			switch (opcode) {
+			case DECL_SEND:
+				ifp->send_flags |= DHCIFF_RAPID_COMMIT;
+				break;
+#if 0 /* ENABLE_DHCP6S */
+			case DECL_ALLOW:
+				ifp->allow_flags |= DHCIFF_RAPID_COMMIT;
+				break;
+#endif
+			default:
+				goto inv_op;
+			}
+			break;
+#if ENABLE_FEATURE_DHCP6_AUTH
+		case DHCPOPT_AUTHINFO:
+			if (opcode != DECL_SEND)
+				goto inv_op;
+			ainfo = find_authinfo(client6_config.auth_list, cfl->ptr);
+			if (ainfo == NULL) {
+				bb_error_msg("%s:%d auth info (%s) is not defined",
+				    client6_config.conffile, cfl->line, cfl->ptr);
+				return -1;
+			}
+			if (ifp->authproto != -1) {
+				bb_error_msg("%s:%d duplicated auth info for %s",
+				    client6_config.conffile, cfl->line, ifp->ifname);
+				return -1;
+			}
+			ifp->authproto = ainfo->protocol;
+			ifp->authalgorithm = ainfo->algorithm;
+			ifp->authrdm = ainfo->rdm;
+			break;
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+		case DHCPOPT_IA_PD:
+		case DHCPOPT_IA_NA:
+			if (opcode != DECL_SEND)
+				goto inv_op;
+			iaid = xatou32(cfl->ptr);
+			iac = find_iaconf(&ifp->iaconf_list, cfl->type, iaid);
+			if (iac != NULL) {
+				bb_error_msg("%s:%d duplicated %s (%u)",
+					client6_config.conffile, cfl->line,
+					dhcp6optstr(cfl->type), iaid);
+				return -1;
+			}
+			iac = find_iaconf(&client6_config.ia_allconflist, cfl->type, iaid);
+			if (iac == NULL) {
+				bb_error_msg("%s:%d %s (%u) is not defined",
+					client6_config.conffile, cfl->line,
+					dhcp6optstr(cfl->type), iaid);
+				return -1;
+			}
+
+			TAILQ_REMOVE(&client6_config.ia_allconflist, iac, link);
+			TAILQ_INSERT_TAIL(&ifp->iaconf_list, iac, link);
+
+			break;
+		case DHCPOPT_SIP:
+		case DHCPOPT_SIPNAME:
+		case DHCPOPT_DNS:
+		case DHCPOPT_DNSNAME:
+		case DHCPOPT_SNTP:
+		case DHCPOPT_NIS:
+		case DHCPOPT_NISNAME:
+		case DHCPOPT_NISP:
+		case DHCPOPT_NISPNAME:
+		case DHCPOPT_BCMCS:
+		case DHCPOPT_BCMCSNAME:
+		case DHCPOPT_REFRESHTIME:
+			if (opcode != DECL_REQUEST)
+				goto inv_op;
+			if (dhcp6_find_listval(&ifp->reqopt_list,
+					DHCP6_LISTVAL_NUM, &cfl->type, 0) != NULL) {
+				bb_error_msg("duplicated request option (%s)",
+				    dhcp6optstr(cfl->type));
+				goto next; /* ignore it */
+			}
+			if (dhcp6_add_listval(&ifp->reqopt_list, 0,
+					DHCP6_LISTVAL_NUM, &cfl->type, NULL) == NULL) {
+				bb_error_msg("can't add an option (%s)",
+					dhcp6optstr(cfl->type));
+				return -1;
+			}
+			break;
+		default:
+			bb_error_msg("%s:%d unsupported option (%s)",
+				client6_config.conffile, cfl->line,
+				dhcp6optstr(cfl->type));
+			return -1;
+		}
+
+ next:
+		;
+	}
+
+	return 0;
+
+ inv_op:
+	bb_error_msg("%s:%d invalid operation (%d) for option (%s)",
+		    client6_config.conffile, cfl->line,
+		    opcode, dhcp6optstr(cfl->type));
+	return -1;
+}
+
+static int add_prefix6(struct dhcp6_list *head, int type, int lvtype,
+		   struct dhcp6_prefix *prefix)
+{
+	struct in6_addr oldaddr;
+	const char *name = dhcp6optstr(type);
+	char p[INET6_ADDRSTRLEN];
+
+	oldaddr = prefix->addr;
+
+	/* additional validation of parameters */
+	if (prefix->plen < 4 || prefix->plen > 128) {
+		bb_error_msg("invalid prefix length: %d", prefix->plen);
+		return -1;
+	}
+	/* clear trailing bits */
+	prefix6_mask(&prefix->addr, prefix->plen);
+	sprint_nip6(p, (const uint8_t *)&prefix->addr);
+	if (!IN6_ARE_ADDR_EQUAL(&oldaddr, &prefix->addr)) {
+		char p0[INET6_ADDRSTRLEN];
+
+		sprint_nip6(p0, (const uint8_t *)&oldaddr);
+		bb_error_msg("prefix %s/%d for %s "
+		    "has a trailing garbage. It should be %s/%d",
+		    p0, prefix->plen, name, p, prefix->plen);
+		/* ignore the error */
+	}
+
+	/* avoid invalid prefix addresses */
+	if (IN6_IS_ADDR_MULTICAST(&prefix->addr) ||
+	    IN6_IS_ADDR_LINKLOCAL(&prefix->addr) ||
+	    IN6_IS_ADDR_SITELOCAL(&prefix->addr)) {
+		bb_error_msg("invalid prefix address: %s", p);
+		return -1;
+	}
+
+	/* prefix duplication check */
+	if (dhcp6_find_listval(head, lvtype, prefix, 0)) {
+		if (lvtype == DHCP6_LISTVAL_PREFIX6) {
+			bb_error_msg("duplicated prefix: %s/%d for %s",
+			    p, prefix->plen, name);
+		} else {
+			bb_error_msg("duplicated address: %s for %s", p, name);
+		}
+		return -1;
+	}
+
+	/* validation about relationship of pltime and vltime */
+	if (prefix->vltime != DHCP6_DURATION_INFINITE &&
+		 (prefix->pltime == DHCP6_DURATION_INFINITE ||
+		 prefix->pltime > prefix->vltime)) {
+		bb_error_msg("%s/%d has larger preferred lifetime than valid lifetime",
+				p, (lvtype == DHCP6_LISTVAL_PREFIX6) ? prefix->plen : 128);
+		return -1;
+	}
+
+	/* insert the new prefix to the chain */
+	if (dhcp6_add_listval(head, type, lvtype, prefix, NULL) == NULL) {
+		return -1;
+	}
+
+	return 0;
+}
+
+struct ia_conf *find_iaconf(const struct ia_conflist *head, dh6cnfopts_t type,
+			uint32_t iaid)
+{
+	struct ia_conf *iac;
+
+	TAILQ_FOREACH(iac, head, link) {
+		if (iac->type == type && iac->iaid == iaid)
+			return iac;
+	}
+
+	return NULL;
+}
+
+struct dhcp6_prefix *find_prefix6(struct dhcp6_list *list,
+				struct dhcp6_prefix *prefix)
+{
+	struct dhcp6_listval *lv;
+
+	TAILQ_FOREACH(lv, list, link) {
+		if (lv->val_prefix6.plen == prefix->plen &&
+		    IN6_ARE_ADDR_EQUAL(&lv->val_prefix6.addr, &prefix->addr)) {
+			return (&lv->val_prefix6);
+		}
+	}
+	return NULL;
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+struct keyinfo *find_key(struct dhcp6_vbuf *realm, uint32_t id)
+{
+	struct keyinfo *key;
+
+	for (key = client6_config.key_list; key; key = key->next) {
+		if (key->keyid == id && dhcp6_vbuf_cmp(&key->realm, realm) == 0) {
+			return key;
+		}
+	}
+
+	return NULL;
+}
+#endif
+
+////////////////////////////////////////////////////////////////////////
+
+
+/* supplement routines for configuration */
+static int add_cflevel0(dh6cnfopts_t type, const char *name, int lineno)
+{
+	struct cf_list *new;
+	struct cf_list *n = client6_config.config_list;
+
+	MAKE_CFLIST(new, type, xstrdup(name), NULL);
+
+	/* check for duplicated configuration */
+	while (n) {
+		if (n->type == new->type && strcmp(n->ptr, new->ptr) == 0) {
+			bb_error_msg("%s:%d duplicated %s name: %s (ignored)\n",
+				client6_config.conffile, lineno, dhcp6optstr(type), name);
+			cleanup_cflist(new);
+			return 0;
+		}
+		n = n->next;
+	}
+
+	/* insert at first pos of list */
+	new->next = client6_config.config_list;
+	if (client6_config.config_list)
+		new->tail = client6_config.config_list->tail;
+	client6_config.config_list = new;
+
+	return 0;
+}
+
+static int add_cfparam(struct cf_list *new)
+{
+	struct cf_list *headp = client6_config.config_list;
+
+	if (headp->sublist == NULL) {
+		new->tail = new;
+		new->next = NULL;
+		headp->sublist = new;
+	} else {
+		/* add to the end of list */
+		headp->sublist->tail->next = new;
+		headp->sublist->tail = new->tail;
+	}
+	return 0;
+}
+
+static int add_cfsubparam(struct cf_list *new, struct cf_list *parent)
+{
+	if (parent->sublist == NULL) {
+		new->tail = new;
+		new->next = NULL;
+		parent->sublist = new;
+	} else {
+		/* add to the end of list */
+		parent->sublist->tail->next = new;
+		parent->sublist->tail = new->tail;
+	}
+	return 0;
+}
+
+static void cleanup_cflist(struct cf_list *cfl)
+{
+	struct cf_list *cfl_next;
+
+	while (cfl) {
+		cfl_next = cfl->next;
+		free(cfl->ptr);
+		if (cfl->sublist)
+			cleanup_cflist(cfl->sublist);
+		free(cfl);
+
+		cfl = cfl_next;
+	}
+}
+
+struct dhcp_cf_options {
+	const char *optname;
+	const int optval;
+	const uint8_t paramt; /* 0-none, 1-string, 2-integer */
+};
+
+static const struct dhcp_cf_options dhcp_option_list[] = {
+    { "rapid-commit",             DHCPOPT_RAPID_COMMIT,  0 },
+    { "ia-pd",                    DHCPOPT_IA_PD,         2 },
+    { "ia-na",                    DHCPOPT_IA_NA,         2 },
+    { "authentication",           DHCPOPT_AUTHINFO,      1 },
+    { "domain-name-servers",      DHCPOPT_DNS,           0 },
+    { "ntp-servers",              DHCPOPT_SNTP,          0 },
+    { "sip-server-address",       DHCPOPT_SIP,           0 },
+    { "nis-server-address",       DHCPOPT_NIS,           0 },
+    { "nisp-server-address",      DHCPOPT_NISP,          0 },
+    { "bcmcs-server-address",     DHCPOPT_BCMCS,         0 },
+#if ENABLE_FEATURE_UDHCP_RFC3397
+    { "domain-name",              DHCPOPT_DNSNAME,       0 },
+    { "sip-server-domain-name",   DHCPOPT_SIPNAME,       0 },
+    { "nis-domain-name",          DHCPOPT_NISNAME,       0 },
+    { "nisp-domain-name",         DHCPOPT_NISPNAME,      0 },
+    { "bcmcs-server-domain-name", DHCPOPT_BCMCSNAME,     0 },
+#endif
+};
+
+static int FAST_FUNC create_iface(int lineno, int kw_ind UNUSED_PARAM, char **varr, int cnt)
+{
+	if (cnt < 2)
+		return -2;
+
+	if (add_cflevel0(DECL_IFACE, varr[1], lineno))
+		return -1;
+
+	return 0;
+}
+
+static int FAST_FUNC create_assoc(int lineno, int kw_ind UNUSED_PARAM, char **varr, int cnt)
+{
+	const char *id;
+	dh6cnfopts_t iatype;
+
+	if (cnt < 2)
+		return -2;
+
+	if (cnt >=3 && strcmp(varr[2], "{"))
+		id = varr[2];
+	else
+		id = "0";
+
+	if (strcasecmp(varr[1], "pd") == 0)
+		iatype = DHCPOPT_IA_PD;
+	else if (strcasecmp(varr[1], "na") == 0)
+		iatype = DHCPOPT_IA_NA;
+	else
+		return -3;
+
+	if (add_cflevel0(iatype, id, lineno))
+		return -1;
+
+	return 0;
+}
+
+static int FAST_FUNC parse_iface(int lineno, int kw_ind, char **varr, int cnt)
+{
+	struct cf_list *l;
+	int i, j;
+
+	switch (kw_ind) {
+	case 0: /* send */
+		MAKE_CFLIST(l, DECL_SEND, NULL, NULL);
+		add_cfparam(l);
+		break;
+	case 1: /* request */
+		MAKE_CFLIST(l, DECL_REQUEST, NULL, NULL);
+		add_cfparam(l);
+		break;
+	case 2: /* script */
+		if (cnt < 2)
+			return -2;
+		MAKE_CFLIST(l, DECL_SCRIPT, xstrdup(varr[1]), NULL);
+		add_cfparam(l);
+		return 0;
+	case 3: /* information-only */
+		MAKE_CFLIST(l, DECL_INFO_ONLY, NULL, NULL);
+		add_cfparam(l);
+		return 0;
+	}
+
+	/* add subparams */
+	for (i = 1; i < cnt; i++) {
+
+		for (j = 0; j < ARRAY_SIZE(dhcp_option_list); j++) {
+			if (strcasecmp(dhcp_option_list[j].optname, varr[i]) == 0) {
+
+			MAKE_CFLIST(l, dhcp_option_list[j].optval, xstrdup(varr[i+1]), NULL);
+			if (dhcp_option_list[j].paramt && (i < cnt - 1))
+				i++;
+			if (add_cfsubparam(l, client6_config.config_list->sublist->tail))
+				return -1;
+			break;
+
+			}
+		}
+
+		if (j >= ARRAY_SIZE(dhcp_option_list))
+		return -3;
+
+	}
+
+	return 0;
+}
+
+static int FAST_FUNC create_prefiff(int lineno, int kw_ind UNUSED_PARAM, char **varr, int cnt)
+{
+	struct cf_list *ifl;
+
+	if (cnt < 2)
+		return -2;
+
+	MAKE_CFLIST(ifl, IACONF_PIF, xstrdup(varr[1]), NULL);
+
+	if (add_cfparam(ifl))
+		return -1;
+
+	return 0;
+}
+
+static int FAST_FUNC parse_prefiff(int lineno, int kw_ind, char **varr, int cnt)
+{
+	struct cf_list *l;
+
+	if (cnt < 2)
+		return -2;
+
+	switch (kw_ind) {
+	case 0: /* sla-id */
+		MAKE_CFLIST(l, IFPARAM_SLA_ID, xstrdup(varr[1]), NULL);
+		break;
+	case 1: /* sla-len */
+		MAKE_CFLIST(l, IFPARAM_SLA_LEN, xstrdup(varr[1]), NULL);
+		break;
+	default:
+		return -1;
+	}
+	if (add_cfsubparam(l, client6_config.config_list->sublist->tail))
+		return -1;
+
+	return 0;
+}
+
+static int FAST_FUNC parse_assoc(int lineno, int kw_ind, char **varr, int cnt)
+{
+	struct cf_list *l;
+	struct dhcp6_prefix *pconf;
+
+	if (cnt < 2)
+		return -2;
+
+	switch (kw_ind) {
+		case 0: /* address */
+			MAKE_CFLIST(l, IACONF_ADDR, NULL, NULL);
+			break;
+		case 1: /* prefix */
+			MAKE_CFLIST(l, IACONF_PREFIX, NULL, NULL);
+			break;
+		default:
+			return -1;
+	}
+	pconf = xzalloc(sizeof(*pconf));
+	if (inet_pton(AF_INET6, varr[1], &pconf->addr) != 1) {
+		bb_error_msg("invalid IPv6 address: %s", varr[1]);
+				free(pconf);
+				return -1;
+	}
+	/* validate other parameters later */
+	pconf->plen = 128; /* XXX this field is ignored */
+	if (cnt < 3) {
+		pconf->pltime = DHCP6_DURATION_INFINITE;
+	} else {
+		pconf->pltime = xatoul(varr[2]);
+		if (cnt < 4)
+			pconf->vltime = DHCP6_DURATION_INFINITE;
+		else
+			pconf->vltime = xatoul(varr[3]);
+	}
+	l->ptr = (void *)pconf;
+
+	if (add_cfparam(l))
+		return -1;
+
+	return 0;
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int FAST_FUNC create_auth(int lineno, int kw_ind UNUSED_PARAM, char **varr, int cnt)
+{
+	if (cnt < 2)
+		return -2;
+
+	if (add_cflevel0(DECL_AUTHINFO, varr[1], lineno))
+		return -1;
+
+	return 0;
+}
+
+static int FAST_FUNC create_keyinfo(int lineno, int kw_ind UNUSED_PARAM, char **varr, int cnt)
+{
+	if (cnt < 2)
+		return -2;
+
+	if (add_cflevel0(DECL_KEYINFO, varr[1], lineno))
+		return -1;
+
+	return 0;
+}
+
+static int FAST_FUNC parse_auth(int lineno, int kw_ind, char **varr, int cnt)
+{
+	struct cf_list *l;
+
+	if (cnt < 2)
+		return -2;
+
+	switch (kw_ind) {
+		case 0: /* protocol */
+			MAKE_CFLIST(l, AUTHPARAM_PROTO, xstrdup(varr[1]), NULL);
+			break;
+		case 1: /* algorithm */
+			MAKE_CFLIST(l, AUTHPARAM_ALG, xstrdup(varr[1]), NULL);
+			break;
+		case 2: /* rdm */
+			MAKE_CFLIST(l, AUTHPARAM_RDM, xstrdup(varr[1]), NULL);
+			break;
+		default:
+			return -1;
+	}
+	if (add_cfparam(l))
+		return -1;
+
+	return 0;
+}
+
+static int FAST_FUNC parse_keyinfo(int lineno, int kw_ind, char **varr, int cnt)
+{
+	struct cf_list *l;
+
+	if (cnt < 2)
+		return -2;
+
+	switch (kw_ind) {
+		case 0: /* realm */
+			MAKE_CFLIST(l, KEYPARAM_REALM, xstrdup(varr[1]), NULL);
+			break;
+		case 1: /* keyid */
+			MAKE_CFLIST(l, KEYPARAM_KEYID, xstrdup(varr[1]), NULL);
+			break;
+		case 2: /* secret */
+			MAKE_CFLIST(l, KEYPARAM_SECRET, qstrdup(varr[1]), NULL);
+			break;
+		case 3: /* expire */
+			MAKE_CFLIST(l, KEYPARAM_EXPIRE, xstrdup(varr[1]), NULL);
+			break;
+		default:
+			return -1;
+	}
+	if (add_cfparam(l))
+		return -1;
+
+	return 0;
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+struct config_keyword;
+
+struct config_keyword {
+	const char *keyword;
+	const struct config_keyword *next_level;
+
+	int (*handler)(int lineno, int kw_ind, char **varr, int cnt) FAST_FUNC;
+};
+
+static const struct config_keyword interface_kw[] = {
+ { "send",             NULL,          &parse_iface    },
+ { "request",          NULL,          &parse_iface    },
+ { "script",           NULL,          &parse_iface    },
+ { "information-only", NULL,          &parse_iface    },
+ { NULL,               NULL,          NULL },
+};
+
+static const struct config_keyword prefiff_kw[] = {
+ { "sla-id",           NULL,          &parse_prefiff  },
+ { "sla-len",          NULL,          &parse_prefiff  },
+ { NULL,               NULL,          NULL },
+};
+
+static const struct config_keyword assoc_kw[] = {
+ { "address",          NULL,          &parse_assoc    },
+ { "prefix",           NULL,          &parse_assoc    },
+ { "prefix-interface", prefiff_kw,    &create_prefiff },
+ { NULL,               NULL,          NULL },
+};
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static const struct config_keyword auth_kw[] = {
+ { "protocol",         NULL,          &parse_auth     },
+ { "algorithm",        NULL,          &parse_auth     },
+ { "rdm",              NULL,          &parse_auth     },
+ { NULL,               NULL,          NULL },
+};
+
+static const struct config_keyword keyinfo_kw[] = {
+ { "realm",            NULL,          &parse_keyinfo  },
+ { "keyid",            NULL,          &parse_keyinfo  },
+ { "secret",           NULL,          &parse_keyinfo  },
+ { "expire",           NULL,          &parse_keyinfo  },
+ { NULL,               NULL,          NULL },
+};
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+static const struct config_keyword level0_kw[] = {
+ { "interface",        interface_kw,  &create_iface   },
+ { "id-assoc",         assoc_kw,      &create_assoc   },
+#if ENABLE_FEATURE_DHCP6_AUTH
+ { "authentication",   auth_kw,       &create_auth    },
+ { "keyinfo",          keyinfo_kw,    &create_keyinfo },
+#endif
+ { NULL,               NULL,          NULL            },
+};
+
+TAILQ_HEAD(keyword6_list, keywords6);
+struct keywords6 {
+	TAILQ_ENTRY(keywords6) link;
+
+	const struct config_keyword *kw;
+};
+
+
+int FAST_FUNC read_config6(const char *file)
+{
+	parser_t *parser;
+	struct keyword6_list kwq_head;
+	struct keywords6 *kl;
+	unsigned i = 0, j, m, n;
+#define MAX_TOKENS	15
+	char *token[MAX_TOKENS];
+	const struct config_keyword *req_next_level = NULL;
+	int ret = 0;
+
+	/* cleanup config int. structures */
+	cleanup_cflist(client6_config.config_list);
+	client6_config.config_list = NULL;
+	TAILQ_INIT(&client6_config.ia_allconflist);
+#if ENABLE_FEATURE_DHCP6_AUTH
+	clear_keys(client6_config.key_list);
+	client6_config.key_list = NULL;
+	clear_authinfo(client6_config.auth_list);
+	client6_config.auth_list = NULL;
+#endif
+	clear_ifconf(0);
+
+	/* Phase I - parse & fill-up config int. structures */
+	TAILQ_INIT(&kwq_head);
+	kl = xzalloc(sizeof(*kl));
+	kl->kw = level0_kw;
+	TAILQ_INSERT_TAIL(&kwq_head, kl, link);
+	parser = config_open(file);
+	while ((n = config_read(parser, token, MAX_TOKENS, 1, "# \t,", PARSE_NORMAL))) {
+		const struct config_keyword *k;
+		int was_found;
+
+		kl = TAILQ_LAST(&kwq_head, keyword6_list);
+		i = 0;
+ restart_scan:
+		if (kl == NULL)
+			goto scan_fail;
+
+		k = kl->kw;
+		j = 0;
+		was_found = 0;
+		/* Just skip alone ';' */
+		if (strcmp(token[i], ";") == 0) {
+			i++;
+		}
+		/* scan for ';' statement trailer */
+		for (m = i; m < n; m++) {
+			char *lc;
+
+			if (strcmp(token[m], "{") == 0 || strcmp(token[m], ";") == 0)
+				break;
+			lc = last_char_is(token[m], ';');
+			if (lc) {
+				*lc = '\0';
+				m++;
+				break;
+			}
+		}
+		/* m contains index of last parameter token */
+		while (i < m && k[j].keyword != NULL) {
+			if (strcasecmp(token[i], k[j].keyword) == 0) {
+				if (k[j].handler != NULL) {
+					log3("parse line(%d): token '%s' nargs=%d", parser->lineno, token[i], m-i);
+					if ((*k[j].handler)(parser->lineno, j, &token[i], m-i) < 0)
+						goto scan_fail;
+
+					i = m;
+				} else {
+					i++;
+				}
+				req_next_level = k[j].next_level;
+				was_found = 1;
+				break;
+			}
+			j++;
+		} /* while(keywords scan) */
+
+		if (i >= n)	// EOL
+			continue;
+
+		if (req_next_level != NULL) {
+			if (strcmp(token[i], "{") != 0) {
+				goto scan_fail;
+			}
+			kl = xzalloc(sizeof(*kl));
+			kl->kw = req_next_level;
+			TAILQ_INSERT_TAIL(&kwq_head, kl, link);
+			req_next_level = NULL;
+			if (++i >= n)	// EOL
+				continue;
+			goto restart_scan;
+		}
+		if (strncmp(token[i], "}", 1) == 0) {
+			TAILQ_REMOVE(&kwq_head, kl, link);
+			free(kl);
+			kl = TAILQ_LAST(&kwq_head, keyword6_list);
+			if (++i >= n)	// EOL
+				continue;
+			goto restart_scan;
+		}
+		if (was_found)
+			goto restart_scan;
+
+ scan_fail:
+		bb_error_msg("%s: can't parse line %u near token '%s'", file, parser->lineno, token[i]);
+		break;
+	} /* while(config_read) */
+	config_close(parser);
+	while ((kl = TAILQ_FIRST(&kwq_head)) != NULL) {
+		TAILQ_REMOVE(&kwq_head, kl, link);
+		free(kl);
+	}
+
+	/* Phase II - validations & cross-checks */
+#if ENABLE_FEATURE_DHCP6_AUTH
+	if (configure_keys())
+		goto cf_fail;
+
+	if (configure_authinfo())
+		goto cf_fail;
+#endif
+	if (configure_ia())
+		goto cf_fail;
+
+	if (configure_interface())
+		goto cf_fail;
+
+	/* unused IA configurations */
+	if (!TAILQ_EMPTY(&client6_config.ia_allconflist)) {
+		bb_error_msg("some IA defined but not used!\n");
+	}
+
+ cf_ret:
+	clear_iaconf(&client6_config.ia_allconflist);
+	cleanup_cflist(client6_config.config_list);
+	client6_config.config_list = NULL;
+	return ret;
+
+ cf_fail:
+	ret = -1;
+	goto cf_ret;
+}
diff -urN busybox-1.36.1-ref/networking/udhcp/dhcp6c_config.h busybox-1.36.1/networking/udhcp/dhcp6c_config.h
--- busybox-1.36.1-ref/networking/udhcp/dhcp6c_config.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.36.1/networking/udhcp/dhcp6c_config.h	2023-05-19 23:01:27.861391752 +0300
@@ -0,0 +1,254 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2002 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN
+
+typedef enum {
+	DHCPOPT_IA_NA			= D6_OPT_IA_NA,
+	DHCPOPT_AUTHINFO		= D6_OPT_AUTH,
+	DHCPOPT_RAPID_COMMIT	= D6_OPT_RAPID_COMMIT,
+	DHCPOPT_SIPNAME			= D6_OPT_SIP_SERVER_D,
+	DHCPOPT_SIP				= D6_OPT_SIP_SERVER_A,
+	DHCPOPT_DNS				= D6_OPT_DNS,
+	DHCPOPT_DNSNAME			= D6_OPT_DNSNAME,
+	DHCPOPT_IA_PD			= D6_OPT_IA_PD,
+	DHCPOPT_NIS				= D6_OPT_NIS_SERVERS,
+	DHCPOPT_NISP			= D6_OPT_NISP_SERVERS,
+	DHCPOPT_NISNAME			= D6_OPT_NIS_DOMAIN,
+	DHCPOPT_NISPNAME		= D6_OPT_NISP_DOMAIN,
+	DHCPOPT_SNTP			= D6_OPT_SNTP_SERVERS,
+	DHCPOPT_REFRESHTIME		= D6_OPT_REFRESHTIME,
+	DHCPOPT_BCMCSNAME		= D6_OPT_BCMCS_SERVER_D,
+	DHCPOPT_BCMCS			= D6_OPT_BCMCS_SERVER_A,
+
+	DECL_IFACE = 100, DECL_AUTHINFO, DECL_KEYINFO,
+	DECL_SEND, DECL_REQUEST, DECL_SCRIPT, DECL_INFO_ONLY,
+/* server only start */
+	DECL_ALLOW, DECL_DUID, DECL_PREFIX, DECL_PREFERENCE,
+	DECL_DELAYEDKEY, DECL_ADDRESS, DECL_RANGE, DECL_ADDRESSPOOL,
+/* server only  end  */
+	IACONF_PIF, IACONF_PREFIX, IACONF_ADDR,
+	IFPARAM_SLA_ID, IFPARAM_SLA_LEN,
+	AUTHPARAM_PROTO, AUTHPARAM_ALG, AUTHPARAM_RDM, AUTHPARAM_KEY,
+	KEYPARAM_REALM, KEYPARAM_KEYID, KEYPARAM_SECRET, KEYPARAM_EXPIRE
+} dh6cnfopts_t;
+
+/* definitions of tail-queue types */
+TAILQ_HEAD(ia_conflist, ia_conf);
+TAILQ_HEAD(pifc_list, prefix_ifconf);
+
+struct dhcp6_poolspec {
+	char *name;
+	uint32_t pltime;
+	uint32_t vltime;
+};
+
+struct dhcp6_range {
+	struct in6_addr min;
+	struct in6_addr max;
+};
+
+struct pool_conf {
+	struct pool_conf *next;
+
+	char *name;
+
+	struct in6_addr min;
+	struct in6_addr max;
+};
+
+/* per-interface information */
+struct dhcp6_if {
+/*	struct dhcp6_if *next;*/
+
+	/* timer for the interface */
+	struct dhcp6_timer *timer;
+
+	/* static parameters of the interface */
+	char *ifname;
+	unsigned int ifid;
+	/* multiple global address configuration is not supported now */
+	struct in6_addr addr; 		/* global address (server only) */
+
+	/* configuration parameters */
+	uint32_t send_flags;
+	uint32_t allow_flags;
+#define DHCIFF_INFO_ONLY    0x1
+#define DHCIFF_RAPID_COMMIT 0x2
+
+	int server_pref;			/* server preference (server only) */
+	struct dhcp6_poolspec pool;	/* address pool (server only) */
+	char *scriptpath;			/* path to config script (client only) */
+
+	struct dhcp6_list reqopt_list;
+	struct ia_conflist iaconf_list;
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	/* authentication information */
+	int authproto;				/* protocol */
+	/* the followings are valid only if authproto is not UNDEF */
+	int authalgorithm;			/* algorithm */
+	int authrdm;				/* replay attack detection method */
+#endif
+};
+
+/* run-time authentication parameters */
+struct authparam {
+	int authproto;
+	int authalgorithm;
+	int authrdm;
+	struct keyinfo *key;
+	int flags;
+#define AUTHPARAM_FLAGS_NOPREVRD	0x1
+
+	uint64_t prevrd;			/* previous RD value provided by the peer */
+};
+
+struct dhcp6_event {
+	TAILQ_ENTRY(dhcp6_event) link;
+
+	const struct dhcp6_if *ifp;
+	struct dhcp6_timer *timer;
+
+	struct dhcp6_vbuf serverid; /* server DUID */
+
+	unsigned long long t_start; /* timestamp(ms) when the 1st msg is sent */
+
+	/* internal timer parameters */
+	unsigned long retrans;
+	unsigned long init_retrans;
+	long max_retrans_cnt;
+	long max_retrans_time;
+	long max_retrans_dur;
+	int timeouts;				/* number of timeouts */
+
+	uint32_t xid;				/* current transaction ID */
+	int state;
+
+	/* list of known servers */
+	struct dhcp6_serverinfo *current_server;
+	struct dhcp6_serverinfo *servers;
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	/* authentication parameters */
+	struct authparam *authparam;
+#endif
+	TAILQ_HEAD(, dhcp6_eventdata) data_list;
+};
+
+struct dhcp6_eventdata {
+	TAILQ_ENTRY(dhcp6_eventdata) link;
+
+	struct dhcp6_event *event;
+	int type;
+	void *data;
+};
+
+struct dhcp6_serverinfo {
+	struct dhcp6_serverinfo *next;
+
+	/* option information provided in the advertisement */
+	struct dhcp6_optinfo optinfo;
+
+	int pref;					/* preference */
+	int active;					/* bool; if this server is active or not */
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	struct authparam *authparam; /* authentication parameters */
+#endif
+	/* TODO: remember available information from the server */
+};
+
+struct prefix_ifconf {
+	TAILQ_ENTRY(prefix_ifconf) link;
+
+	char *ifname;		/* interface name such as ne0 */
+	int sla_len;		/* SLA ID length in bits */
+	uint32_t sla_id;	/* need more than 32bits? */
+	int ifid_len;		/* interface ID length in bits */
+	int ifid_type;		/* EUI-64 and manual (unused?) */
+	char ifid[16];		/* Interface ID, up to 128bits */
+};
+#define IFID_LEN_DEFAULT 64
+#define SLA_LEN_DEFAULT  16
+
+struct ia_conf {
+	TAILQ_ENTRY(ia_conf) link;
+
+	int type;
+	uint32_t iaid;
+
+	TAILQ_HEAD(, ia) iadata; /* struct ia is an opaque type */
+
+	/* type dependent values follow */
+	struct dhcp6_list prefix_list;
+	struct pifc_list iapd_pif_list;
+};
+
+struct cf_list;
+struct authinfo;
+
+struct client6_config_t {
+	const char *conffile;
+
+	struct dhcp6_if dhcp6c_if;
+
+	struct ia_conflist ia_allconflist;
+#if ENABLE_FEATURE_DHCP6_AUTH
+	struct keyinfo *key_list;
+	struct authinfo *auth_list;
+#endif
+
+	/* config parser internal tree */
+	struct cf_list *config_list;
+
+	/* timer */
+	LIST_HEAD(, dhcp6_timer) timer_head;
+	unsigned long long tm_sentinel;
+	struct timeval tm_check;
+
+	/* event queue */
+	TAILQ_HEAD(, dhcp6_event) event_list;
+} FIX_ALIASING;
+
+#define client6_config (*(struct client6_config_t*)(&bb_common_bufsiz1))
+
+void clear_ifconf(int destroy);
+
+struct prefix_ifconf *find_prefixifconf(char *);
+struct dhcp6_prefix *find_prefix6(struct dhcp6_list *, struct dhcp6_prefix *);
+struct ia_conf *find_iaconf(const struct ia_conflist *, dh6cnfopts_t, uint32_t);
+#if ENABLE_FEATURE_DHCP6_AUTH
+struct keyinfo *find_key(struct dhcp6_vbuf *, uint32_t);
+#endif
+
+int read_config6(const char *file) FAST_FUNC;
+
+POP_SAVED_FUNCTION_VISIBILITY
diff -urN busybox-1.36.1-ref/networking/udhcp/dhcp6c_ia.c busybox-1.36.1/networking/udhcp/dhcp6c_ia.c
--- busybox-1.36.1-ref/networking/udhcp/dhcp6c_ia.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.36.1/networking/udhcp/dhcp6c_ia.c	2023-05-19 23:01:27.861391752 +0300
@@ -0,0 +1,886 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2003 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <netinet/in.h>
+
+#include "dhcp6c.h"
+
+typedef enum {IAS_ACTIVE, IAS_RENEW, IAS_REBIND} iastate_t;
+
+TAILQ_HEAD(iaprefix_list, iaprefix);
+
+struct iaprefix {
+	TAILQ_ENTRY(iaprefix) link;
+
+	struct dhcp6_prefix pa;
+	time_t updatetime;
+	struct dhcp6_timer *timer;
+	struct iactl *ctl;
+
+	union {
+		TAILQ_HEAD(, dhcp6_ifprefix) ifprefix_list; /* interface prefixes */
+		const struct dhcp6_if *dhcpif;
+	} u;
+};
+
+struct ia {
+	TAILQ_ENTRY(ia) link;
+
+	/* back pointer to configuration */
+	struct ia_conf *conf;
+
+	/* common parameters of IA */
+	uint32_t t1;				/* duration for renewal */
+	uint32_t t2;				/* duration for rebind  */
+
+	/* internal parameters for renewal/rebinding */
+	iastate_t state;
+	struct dhcp6_timer *timer;
+
+	/* DHCP related parameters */
+	struct dhcp6_if *ifp;		/* DHCP interface */
+	struct dhcp6_vbuf serverid; /* the server ID that provided this IA */
+
+	/* control information shared with each particular config routine */
+	struct iactl *ctl;
+
+	/* authentication parameters for transaction with servers on this IA */
+	struct authparam *authparam;
+};
+
+struct iactl {
+	struct ia *iactl_ia;		/* back pointer to IA */
+
+	int type;
+
+	struct pifc_list *pifc_head;
+	struct iaprefix_list iaprefix_head;
+};
+
+struct dhcp6_ifprefix {
+	TAILQ_ENTRY(dhcp6_ifprefix) plink;
+
+	/* interface configuration */
+	struct prefix_ifconf *ifconf;
+
+	/* interface prefix parameters */
+	struct in6_addr paddr;
+	int plen;
+
+	/* address assigned on the interface based on the prefix */
+	struct in6_addr ifaddr;
+};
+
+
+void destruct_iadata(struct dhcp6_eventdata *evd);
+
+static int prepare_iaevent(struct ia *, int);
+static int reestablish_ia(struct ia *);
+static void remove_ia(struct ia *);
+static struct ia *get_ia(struct dhcp6_if *, struct ia_conf *,
+    struct dhcp6_listval *, struct dhcp6_vbuf *);
+static struct dhcp6_timer *ia_timo(void *);
+
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+static const char *iastatestr(iastate_t);
+#endif
+
+static int update_prefix6(struct ia *, struct dhcp6_listval *,
+        struct pifc_list *, const struct dhcp6_if *, struct iactl **);
+static struct iaprefix *find_iaprefix(struct iaprefix_list *,
+    struct dhcp6_prefix *, int);
+static int remove_iaprefix(struct iaprefix *, int);
+
+static int iapref_renew(struct iactl *, struct dhcp6_ia *,
+        struct dhcp6_eventdata *);
+static ALWAYS_INLINE int pref_isvalid(struct iactl *);
+static uint32_t pref_duration(struct iactl *);
+static void pref_cleanup(struct iactl *);
+static struct dhcp6_timer *iapref_timo(void *);
+static int add_ifprefix(struct iaprefix *,
+    struct dhcp6_prefix *, struct prefix_ifconf *);
+
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static struct authparam *copy_authparam(struct authparam *authparam) RETURNS_MALLOC;
+
+static struct authparam *copy_authparam(struct authparam *authparam)
+{
+	struct authparam *dst = malloc_or_warn(sizeof(*dst));
+
+	if (dst == NULL)
+		return NULL;
+
+	memcpy(dst, authparam, sizeof(*dst));
+
+	return dst;
+}
+
+static int update_authparam(struct ia *ia, struct authparam *authparam)
+{
+	if (authparam == NULL)
+		return 0;
+
+	if (ia->authparam == NULL) {
+		ia->authparam = copy_authparam(authparam);
+		if (ia->authparam == NULL) {
+			return -1;
+		}
+		return 0;
+	}
+
+	/* update the previous RD value and flags */
+	ia->authparam->prevrd = authparam->prevrd;
+	ia->authparam->flags = authparam->flags;
+
+	return 0;
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+void update_ia(struct dhcp6_list *iahead, struct dhcp6_if *ifp,
+	  struct dhcp6_vbuf *serverid
+	  IF_FEATURE_DHCP6_AUTH(,struct authparam *authparam))
+{
+	struct ia *ia;
+	struct ia_conf *iac;
+	struct dhcp6_listval *iav, *siav;
+
+	TAILQ_FOREACH(iav, iahead, link) {
+		/* if we're not interested in this IA, ignore it. */
+		iac = find_iaconf(&ifp->iaconf_list, iav->dh6optype, iav->val_ia.iaid);
+		if (iac == NULL)
+			continue;
+
+		/* validate parameters */
+		/*
+		 * If a client receives an IA_NA with T1 greater than T2, and
+		 * both T1 and T2 are greater than 0, the client discards the
+		 * IA_NA option and processes the remainder of the message as
+		 * though the server had not included the invalid IA_NA option.
+		 * [RFC3315 22.4]
+		 * We apply the same rule to IA_PD as well.
+		 */
+		if (iav->val_ia.t2 != 0 && iav->val_ia.t1 > iav->val_ia.t2) {
+			bb_error_msg("invalid IA: T1(%u) > T2(%u)\n",
+			    iav->val_ia.t1, iav->val_ia.t2);
+			continue;
+		}
+
+		/* locate the local IA or make a new one */
+		ia = get_ia(ifp, iac, iav, serverid);
+		if (ia == NULL)
+			continue;
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+		/* update authentication parameters */
+		if (update_authparam(ia, authparam)) {
+			bb_error_msg("can't update authentication param for %s, ID: %u",
+				dhcp6optstr(iac->type), iac->iaid);
+			remove_ia(ia);
+			continue;
+		}
+#endif
+
+		/* update IA configuration information */
+		TAILQ_FOREACH(siav, &iav->sublist, link) {
+			char p[INET6_ADDRSTRLEN];
+
+			switch (siav->lvtype) {
+			case DHCP6_LISTVAL_PREFIX6:
+				/* add or update the prefix */
+				if (update_prefix6(ia, siav, &iac->iapd_pif_list, ifp, &ia->ctl)) {
+					sprint_nip6(p, (const uint8_t *)&siav->val_prefix6.addr);
+					bb_error_msg("can't update a prefix %s/%d",
+					    p, siav->val_prefix6.plen);
+				}
+				break;
+			case DHCP6_LISTVAL_STATEFULADDR6:
+				if (update_prefix6(ia, siav, NULL, ifp, &ia->ctl)) {
+					sprint_nip6(p, (const uint8_t *)&siav->val_statefuladdr6.addr);
+					bb_error_msg("can't update an address %s", p);
+				}
+				break;
+			case DHCP6_LISTVAL_NUM16:
+				bb_error_msg("status code for %s-%u: %s",
+				    dhcp6optstr(iav->dh6optype), iav->val_ia.iaid,
+				    dhcp6stcodestr(siav->val_num16));
+				if ((ia->state == IAS_RENEW || ia->state == IAS_REBIND) &&
+				    siav->val_num16 == D6_OPT_STCODE_NOBINDING) {
+					/*
+					 * For each IA in the original Renew or
+					 * Rebind message, the client
+					 * sends a Request message if the IA
+					 * contained a Status Code option
+					 * with the NoBinding status.
+					 * [RFC3315 18.1.8]
+					 * XXX: what about the PD case?
+					 */
+					bb_error_msg("receive NoBinding against "
+					    "renew/rebind for %s-%u",
+					    dhcp6optstr(ia->conf->type), ia->conf->iaid);
+					reestablish_ia(ia);
+					goto nextia;
+				}
+				break;
+			default:
+				bb_error_msg("impossible subopt");
+				goto nextia;
+			}
+		}
+
+		/* see if this IA is still valid.  if not, remove it. */
+		if (ia->ctl == NULL || !pref_isvalid(ia->ctl)) {
+			log1("%s-%u invalidated",
+				dhcp6optstr(ia->conf->type), ia->conf->iaid);
+			remove_ia(ia);
+			continue;
+		}
+
+		/* if T1 or T2 is 0, determine appropriate values locally. */
+		if (ia->t1 == 0 || ia->t2 == 0) {
+			uint32_t duration;
+
+			if (ia->ctl)
+				duration = pref_duration(ia->ctl);
+			else
+				duration = 1800; /* 30min. XXX: no rationale */
+
+			if (ia->t1 == 0) {
+				if (duration == DHCP6_DURATION_INFINITE)
+					ia->t1 = DHCP6_DURATION_INFINITE;
+				else
+					ia->t1 = duration / 2;
+			}
+			if (ia->t2 == 0) {
+				if (duration == DHCP6_DURATION_INFINITE)
+					ia->t2 = DHCP6_DURATION_INFINITE;
+				else
+					ia->t2 = duration * 4 / 5;
+			}
+
+			/* make sure T1 <= T2 */
+			if (ia->t1 > ia->t2)
+				ia->t1 = ia->t2 * 5 / 8;
+
+			bb_error_msg("T1(%u) and/or T2(%u) is locally determined",
+						ia->t1, ia->t2);
+		}
+
+		/*
+		 * Be proactive for too-small timeout values.  Note that
+		 * the adjusted values may make some information expire
+		 * without renewal.
+		 */
+		if (ia->t2 < DHCP6_DURATION_MIN) {
+			bb_error_msg("T1 (%u) or T2 (%u) is too small", ia->t1, ia->t2);
+			ia->t2 = DHCP6_DURATION_MIN;
+			ia->t1 = ia->t2 * 5 / 8;
+			bb_error_msg(" adjusted to %u and %u", ia->t1, ia->t2);
+		}
+
+		/* set up a timer for this IA. */
+		if (ia->t1 == DHCP6_DURATION_INFINITE) {
+			if (ia->timer) {
+				dhcp6_timer_remove(&ia->timer);
+			}
+		} else {
+			if (ia->timer == NULL) {
+				ia->timer = dhcp6_timer_add(ia_timo, ia);
+			}
+			dhcp6_timer_set(ia->t1 * 1000ULL, ia->timer);
+		}
+
+		ia->state = IAS_ACTIVE;
+
+	  nextia:
+		;
+	}
+}
+
+static int prepare_iaevent(struct ia *ia, int dhcpstate)
+{
+	struct dhcp6_event *ev;
+	struct dhcp6_ia iaparam;
+	struct dhcp6_eventdata *evd;
+
+	ev = dhcp6_create_event(ia->ifp, dhcpstate);
+
+	if (dhcpstate == DHCP6S_RELEASE ||
+	    dhcpstate == DHCP6S_REQUEST ||
+	    dhcpstate == DHCP6S_RENEW
+	   ) {
+		dhcp6_vbuf_copy(&ev->serverid, &ia->serverid);
+	}
+
+	evd = xzalloc(sizeof(*evd));
+	evd->event = ev;
+	memset(&iaparam, 0, sizeof(iaparam));
+	iaparam.iaid = ia->conf->iaid;
+	/* XXX: should we set T1/T2 to 0 on release?  spec is silent on this. */
+	iaparam.t1 = ia->t1;
+	iaparam.t2 = ia->t2;
+
+	if (ia->ctl && iapref_renew(ia->ctl, &iaparam, evd)) {
+		bb_error_msg("can't prepare IA data");
+			goto fail;
+	}
+	TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	if (ia->authparam != NULL) {
+		ev->authparam = copy_authparam(ia->authparam);
+		if (ev->authparam == NULL) {
+			goto fail;
+		}
+	}
+#endif
+
+	ev->timeouts = 0;
+	dhcp6_set_timeoparam(ev);
+	dhcp6_reset_timer(ev);
+
+	client6_send(ev);
+	return 0;
+
+fail:
+	if (ev)
+		dhcp6_remove_event(ev);
+	return -1;
+}
+
+static int reestablish_ia(struct ia *ia)
+{
+
+	log1("re-establishing %s-%u",
+			dhcp6optstr(ia->conf->type), ia->conf->iaid);
+
+	if (ia->state != IAS_RENEW && ia->state != IAS_REBIND) {
+		bb_error_msg_and_die("invalid IA state (%d)", ia->state);
+	}
+
+	/* we don't need a timer for the IA (see comments in ia_timo()) */
+	if (ia->timer)
+		dhcp6_timer_remove(&ia->timer);
+
+	return prepare_iaevent(ia, DHCP6S_REQUEST);
+}
+
+void release_all_ia(struct dhcp6_if *ifp)
+{
+	struct ia_conf *iac;
+	struct ia *ia, *ia_next;
+
+	TAILQ_FOREACH(iac, &ifp->iaconf_list, link) {
+		for (ia = TAILQ_FIRST(&iac->iadata); ia; ia = ia_next) {
+			ia_next = TAILQ_NEXT(ia, link);
+
+			log1("release an %s-%u",
+				dhcp6optstr(ia->conf->type), ia->conf->iaid);
+
+			prepare_iaevent(ia, DHCP6S_RELEASE);
+
+			/*
+			 * The client MUST stop using all of the addresses
+			 * being released as soon as the client begins the
+			 * Release message exchange process.
+			 * [RFC3315 Section 18.1.6]
+			 */
+			remove_ia(ia);
+		}
+	}
+}
+
+static void remove_ia(struct ia *ia)
+{
+	struct ia_conf *iac = ia->conf;
+	struct dhcp6_if *ifp = ia->ifp;
+
+	log1("remove an %s-%u", dhcp6optstr(ia->conf->type), ia->conf->iaid);
+
+	TAILQ_REMOVE(&iac->iadata, ia, link);
+
+	dhcp6_vbuf_free(&ia->serverid);
+
+	if (ia->timer)
+		dhcp6_timer_remove(&ia->timer);
+
+	if (ia->ctl)
+		pref_cleanup(ia->ctl);
+
+	free(ia->authparam);
+	free(ia);
+
+	client6_start(ifp);
+}
+
+static struct dhcp6_timer *ia_timo(void *arg)
+{
+	struct ia *ia = (struct ia *)arg;
+	int dhcpstate;
+
+	log1("timeout for %s-%u, state=%s",
+	    dhcp6optstr(ia->conf->type), ia->conf->iaid, iastatestr(ia->state));
+
+	switch (ia->state) {
+	case IAS_ACTIVE:
+		ia->state = IAS_RENEW;
+		dhcpstate = DHCP6S_RENEW;
+		dhcp6_timer_set((ia->t1 < ia->t2) ? (ia->t2 - ia->t1) * 1000ULL : 0,
+						ia->timer);
+		break;
+	case IAS_RENEW:
+		ia->state = IAS_REBIND;
+		dhcpstate = DHCP6S_REBIND;
+
+		/*
+		 * We need keep DUID for sending Release in this state.
+		 * But we don't need a timer for the IA.  We'll just wait for a
+		 * reply for the REBIND until all associated configuration
+		 * parameters for this IA expire.
+		 */
+		dhcp6_timer_remove(&ia->timer);
+		break;
+	default:
+		bb_error_msg("invalid IA state (%d)", ia->state);
+		return NULL;	/* XXX */
+	}
+
+	if (prepare_iaevent(ia, dhcpstate) == 0)
+		return ia->timer;
+	else
+		return NULL;
+}
+
+static struct ia *get_ia(struct dhcp6_if *ifp,
+	struct ia_conf *iac, struct dhcp6_listval *iaparam,
+	struct dhcp6_vbuf *serverid)
+{
+	struct ia *ia;
+	IF_UDHCP_VERBOSE(bool create = false;)
+
+	TAILQ_FOREACH(ia, &iac->iadata, link) {
+		if (ia->conf->type == iaparam->dh6optype &&
+		    ia->conf->iaid == iaparam->val_ia.iaid)
+			break;
+	}
+
+	if (ia == NULL) {
+		ia = xzalloc(sizeof(*ia));
+		ia->state = IAS_ACTIVE;
+
+		TAILQ_INSERT_TAIL(&iac->iadata, ia, link);
+		ia->conf = iac;
+
+		IF_UDHCP_VERBOSE(create = true;)
+	} else {
+		dhcp6_vbuf_free(&ia->serverid);
+	}
+
+	ia->t1 = iaparam->val_ia.t1;
+	ia->t2 = iaparam->val_ia.t2;
+	ia->ifp = ifp;
+	dhcp6_vbuf_copy(&ia->serverid, serverid);
+
+	log1("%s an %s-%u", create ? "make" : "update",
+	    dhcp6optstr(iaparam->dh6optype), ia->conf->iaid);
+
+	return ia;
+}
+
+
+void destruct_iadata(struct dhcp6_eventdata *evd)
+{
+	struct dhcp6_list *ial;
+
+	if (evd->type != D6_OPT_IA_PD && evd->type != D6_OPT_IA_NA) {
+		bb_error_msg_and_die("impossible IA type %d", evd->type);
+	}
+
+	ial = (struct dhcp6_list *)evd->data;
+	dhcp6_clear_list(ial);
+	free(ial);
+
+	free(evd);
+}
+
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+static const char *iastatestr(iastate_t state)
+{
+	switch (state) {
+	case IAS_ACTIVE:
+		return "ACTIVE";
+	case IAS_RENEW:
+		return "RENEW";
+	case IAS_REBIND:
+		return "REBIND";
+	default:
+		return "???";	/* should be a bug */
+	}
+}
+#endif
+
+
+static int update_prefix6(struct ia *ia, struct dhcp6_listval *lv,
+		struct pifc_list *pifc,	const struct dhcp6_if * dhcpifp,
+		struct iactl **ctlp)
+{
+	struct iactl *iac = (struct iactl *)(*ctlp);
+	struct iaprefix *sp;
+	struct dhcp6_prefix pinfo;
+	struct prefix_ifconf *pif;
+	int spcreate = 0;
+	char p[INET6_ADDRSTRLEN];
+
+	switch (lv->lvtype) {
+		case DHCP6_LISTVAL_PREFIX6:
+			memcpy(&pinfo, &lv->uv.uv_prefix6, sizeof(pinfo));
+			break;
+		case DHCP6_LISTVAL_STATEFULADDR6:
+			memcpy(&pinfo, &lv->uv.uv_statefuladdr6, sizeof(struct dhcp6_statefuladdr));
+			pinfo.plen = 128;
+			break;
+		default:
+			break;
+	}
+
+	/*
+	 * A client discards any addresses for which the preferred
+         * lifetime is greater than the valid lifetime.
+	 * [RFC3315 22.6]
+	 */
+	sprint_nip6(p, (const uint8_t *)&pinfo.addr);
+	if (pinfo.vltime != DHCP6_DURATION_INFINITE &&
+	    (pinfo.pltime == DHCP6_DURATION_INFINITE ||
+	    pinfo.pltime > pinfo.vltime)) {
+		bb_error_msg("%s/%d has larger preferred lifetime than valid lifetime",
+				p, pinfo.plen);
+		return -1;
+	}
+
+	if (iac == NULL) {
+		iac = xzalloc(sizeof(*iac));
+
+		iac->iactl_ia = ia;
+		iac->type = (lv->lvtype == DHCP6_LISTVAL_PREFIX6) ?
+					D6_OPT_IA_PD : D6_OPT_IA_NA;
+
+		iac->pifc_head = pifc;
+		TAILQ_INIT(&iac->iaprefix_head);
+		*ctlp = (struct iactl *)iac;
+	}
+
+	/* search for the given prefix, and make a new one if it fails */
+	sp = find_iaprefix(&iac->iaprefix_head, &pinfo,
+					(lv->lvtype==DHCP6_LISTVAL_PREFIX6));
+	if (sp == NULL) {
+		sp = xzalloc(sizeof(*sp));
+		sp->pa.addr = pinfo.addr;
+		sp->pa.plen = pinfo.plen;
+		sp->ctl = iac;
+
+		if (lv->lvtype == DHCP6_LISTVAL_PREFIX6)
+			TAILQ_INIT(&sp->u.ifprefix_list);
+
+		TAILQ_INSERT_TAIL(&iac->iaprefix_head, sp, link);
+
+		spcreate = 1;
+	}
+
+	/* update the timestamp of update */
+	sp->updatetime = time(NULL);
+
+	/* update the prefix according to pinfo */
+	sp->pa.pltime = pinfo.pltime;
+	sp->pa.vltime = pinfo.vltime;
+	if (lv->lvtype == DHCP6_LISTVAL_STATEFULADDR6)
+		sp->u.dhcpif = dhcpifp;
+
+	log2("%s a address %s/%d pltime=%u, vltime=%u",
+	    spcreate ? "create" : "update",
+	    p, pinfo.plen, pinfo.pltime, pinfo.vltime);
+
+	/* update prefix interfaces if necessary */
+	if (sp->pa.vltime != 0) {
+		if (lv->lvtype == DHCP6_LISTVAL_PREFIX6 && spcreate) {
+			TAILQ_FOREACH(pif, iac->pifc_head, link) {
+			/*
+			 * The requesting router MUST NOT assign any delegated
+			 * prefixes or subnets from the delegated prefix(es) to
+			 * the link through which it received the DHCP message
+			 * from the delegating router.
+			 * [RFC3633 Section 12.1]
+			 */
+				if (strcmp(pif->ifname, dhcpifp->ifname) == 0) {
+					bb_error_msg("skip %s as a prefix interface",
+					    dhcpifp->ifname);
+					continue;
+				}
+
+				add_ifprefix(sp, &pinfo, pif);
+			}
+		}
+		else if (lv->lvtype == DHCP6_LISTVAL_STATEFULADDR6) {
+			if (ifaddrconf(IFADDRCONF_ADD, sp->u.dhcpif->ifname, &sp->pa.addr,
+				 128, sp->pa.pltime, sp->pa.vltime) < 0)
+				return -1;
+		}
+	}
+
+	/*
+	 * If the new vltime is 0, this prefix immediately expires.
+	 * Otherwise, set up or update the associated timer.
+	 */
+	switch (sp->pa.vltime) {
+	case 0:
+		remove_iaprefix(sp, (lv->lvtype == DHCP6_LISTVAL_PREFIX6) ?
+				     D6_OPT_IA_PD : D6_OPT_IA_NA);
+		break;
+	case DHCP6_DURATION_INFINITE:
+		if (sp->timer)
+			dhcp6_timer_remove(&sp->timer);
+		break;
+	default:
+		if (sp->timer == NULL) {
+			sp->timer = dhcp6_timer_add(iapref_timo, sp);
+		}
+		/* update the timer */
+		dhcp6_timer_set(sp->pa.vltime * 1000ULL, sp->timer);
+		break;
+	}
+
+	return 0;
+}
+
+static struct iaprefix *find_iaprefix(struct iaprefix_list *head, struct dhcp6_prefix *addr,
+		int match_plen)
+{
+	struct iaprefix *sp;
+
+	TAILQ_FOREACH(sp, head, link) {
+		if (!IN6_ARE_ADDR_EQUAL(&sp->pa.addr, &addr->addr))
+			continue;
+		if (match_plen == 0 || sp->pa.plen == addr->plen)
+			return sp;
+	}
+
+	return NULL;
+}
+
+static int remove_iaprefix(struct iaprefix *sp, int type)
+{
+	int ret = 0;
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+	char a[INET6_ADDRSTRLEN];
+
+	sprint_nip6(a, (const uint8_t *)&sp->pa.addr);
+	log2("remove an address %s/%d", a, sp->pa.plen);
+#endif
+
+	if (sp->timer)
+		dhcp6_timer_remove(&sp->timer);
+
+	if (type == D6_OPT_IA_PD) {
+		struct dhcp6_ifprefix *ip;
+
+		/* remove all interface prefixes */
+		while ((ip = TAILQ_FIRST(&sp->u.ifprefix_list)) != NULL) {
+			TAILQ_REMOVE(&sp->u.ifprefix_list, ip, plink);
+			ifaddrconf(IFADDRCONF_REMOVE, ip->ifconf->ifname,
+						&ip->ifaddr, ip->plen,
+						DHCP6_DURATION_INFINITE, DHCP6_DURATION_INFINITE);
+			free(ip);
+		}
+	} else {
+		ret = ifaddrconf(IFADDRCONF_REMOVE, sp->u.dhcpif->ifname, &sp->pa.addr,
+						128, sp->pa.pltime, sp->pa.vltime);
+	}
+
+	TAILQ_REMOVE(&sp->ctl->iaprefix_head, sp, link);
+	free(sp);
+	return ret;
+}
+
+static ALWAYS_INLINE int pref_isvalid(struct iactl *iac)
+{
+	if (TAILQ_EMPTY(&iac->iaprefix_head))
+		return 0;	/* this IA is invalid */
+	return 1;
+}
+
+static uint32_t pref_duration(struct iactl *iac)
+{
+	struct iaprefix *sp;
+	uint32_t base = DHCP6_DURATION_INFINITE, pltime, passed;
+	time_t now;
+
+	/* Determine the smallest period until pltime expires. */
+	now = time(NULL);
+	TAILQ_FOREACH(sp, &iac->iaprefix_head, link) {
+		passed = now > sp->updatetime ? (uint32_t)(now - sp->updatetime) : 0;
+		pltime = sp->pa.pltime > passed ? sp->pa.pltime - passed : 0;
+
+		if (base == DHCP6_DURATION_INFINITE || pltime < base)
+			base = pltime;
+	}
+
+	return base;
+}
+
+static void pref_cleanup(struct iactl *iac)
+{
+	struct iaprefix *sp;
+
+	while ((sp = TAILQ_FIRST(&iac->iaprefix_head)) != NULL) {
+		TAILQ_REMOVE(&iac->iaprefix_head, sp, link);
+		remove_iaprefix(sp, iac->type);
+	}
+
+	free(iac);
+}
+
+static int iapref_renew(struct iactl *iac, struct dhcp6_ia *iaparam,
+		struct dhcp6_eventdata *evd)
+{
+	struct iaprefix *sp;
+	struct dhcp6_list *ial = NULL, pl;
+
+	TAILQ_INIT(&pl);
+	TAILQ_FOREACH(sp, &iac->iaprefix_head, link) {
+		if (dhcp6_add_listval(&pl, iac->type,
+		    (iac->type == D6_OPT_IA_PD) ? DHCP6_LISTVAL_PREFIX6 : DHCP6_LISTVAL_STATEFULADDR6,
+		    &sp->pa, NULL) == NULL)
+			goto fail;
+	}
+
+	ial = xmalloc(sizeof(*ial));
+	TAILQ_INIT(ial);
+	if (dhcp6_add_listval(ial, iac->type, DHCP6_LISTVAL_IA, iaparam, &pl) == NULL)
+		goto fail;
+	dhcp6_clear_list(&pl);
+
+	evd->type = iac->type;
+	evd->data = ial;
+
+	return 0;
+
+  fail:
+	dhcp6_clear_list(&pl);
+	free(ial);
+	return -1;
+}
+
+static struct dhcp6_timer *iapref_timo(void *arg)
+{
+	struct iaprefix *sp = (struct iaprefix *)arg;
+	struct ia *ia = sp->ctl->iactl_ia;
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+	char a[INET6_ADDRSTRLEN];
+
+	sprint_nip6(a, (const uint8_t *)&sp->pa.addr);
+	log1("address timeout for %s/%d", a, sp->pa.plen);
+#endif
+
+	if (sp->timer)
+		dhcp6_timer_remove(&sp->timer);
+
+	remove_iaprefix(sp, sp->ctl->type);
+
+	/* see if this IA is still valid.  if not, remove it. */
+	if (ia->ctl == NULL || !pref_isvalid(ia->ctl)) {
+		log1("%s-%u is invalidated",
+		    dhcp6optstr(ia->conf->type), ia->conf->iaid);
+		remove_ia(ia);
+	}
+
+	return NULL;
+}
+
+static int add_ifprefix(struct iaprefix *iaprefix,
+		struct dhcp6_prefix *prefix, struct prefix_ifconf *pconf)
+{
+	struct dhcp6_ifprefix *ifpfx = NULL;
+	uint32_t sla_id;
+	char *sp;
+	int b, i;
+
+	ifpfx = xzalloc(sizeof(*ifpfx));
+
+	ifpfx->ifconf = pconf;
+
+	ifpfx->paddr = prefix->addr;
+	ifpfx->plen = prefix->plen + pconf->sla_len;
+	/*
+	 * XXX: our current implementation assumes ifid len is a multiple of 8
+	 */
+	if ((pconf->ifid_len % 8) != 0) {
+		bb_error_msg("length of interface ID must be multiple of 8");
+		goto bad;
+	}
+	if (ifpfx->plen + pconf->ifid_len < 0 ||
+	    ifpfx->plen + pconf->ifid_len > 128) {
+		bb_error_msg("invalid prefix length: %d + %d + %d",
+			prefix->plen, pconf->sla_len, pconf->ifid_len);
+		goto bad;
+	}
+
+	/* copy prefix and SLA ID */
+	b = prefix->plen;
+	for (i = 0, b = prefix->plen; b > 0; b -= 8, i++) {
+		ifpfx->paddr.s6_addr[i] = prefix->addr.s6_addr[i];
+	}
+	sla_id = htonl(pconf->sla_id);
+	sp = ((char *)&sla_id + 3);
+	i = (128 - pconf->ifid_len) / 8;
+	for (b = pconf->sla_len; b > 7; b -= 8, sp--) {
+		ifpfx->paddr.s6_addr[--i] = *sp;
+	}
+	if (b) {
+		ifpfx->paddr.s6_addr[--i] |= *sp;
+	}
+
+	/* configure the corresponding address */
+	ifpfx->ifaddr = ifpfx->paddr;
+	for (i = 15; i >= pconf->ifid_len / 8; i--) {
+		ifpfx->ifaddr.s6_addr[i] = pconf->ifid[i];
+	}
+	if (ifaddrconf(IFADDRCONF_ADD, ifpfx->ifconf->ifname, &ifpfx->ifaddr,
+		 ifpfx->plen, DHCP6_DURATION_INFINITE, DHCP6_DURATION_INFINITE))
+		goto bad;
+
+	/* TODO: send a control message for other processes */
+
+	TAILQ_INSERT_TAIL(&iaprefix->u.ifprefix_list, ifpfx, plink);
+
+	return 0;
+
+  bad:
+	free(ifpfx);
+	return -1;
+}
diff -urN busybox-1.36.1-ref/networking/udhcp/dhcp6c_script.c busybox-1.36.1/networking/udhcp/dhcp6c_script.c
--- busybox-1.36.1-ref/networking/udhcp/dhcp6c_script.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.36.1/networking/udhcp/dhcp6c_script.c	2023-05-19 23:01:27.861391752 +0300
@@ -0,0 +1,152 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2003 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include "dhcp6c.h"
+
+typedef struct {
+	const char *name;
+	int type;
+} envp_list_t;
+
+static const envp_list_t client6_envp_list[] = {
+    { "new_sip_servers",		D6_OPT_SIP_SERVER_A   },
+    { "new_sip_name",			D6_OPT_SIP_SERVER_D   },
+    { "new_domain_name_servers",D6_OPT_DNS            },
+    { "new_domain_name",		D6_OPT_DNSNAME        },
+    { "new_sntp_servers",		D6_OPT_SNTP_SERVERS   },
+    { "new_ntp_servers",		D6_OPT_NTP_SERVER     },
+    { "new_nis_servers",		D6_OPT_NIS_SERVERS    },
+    { "new_nis_name", 			D6_OPT_NIS_DOMAIN     },
+    { "new_nisp_servers",		D6_OPT_NISP_SERVERS   },
+    { "new_nisp_name",			D6_OPT_NISP_DOMAIN    },
+};
+
+char **fill_envp_client6(struct dhcp6_optinfo *optinfo, const char *ifname)
+{
+	int i, sz, envc, elen;
+	char **envp, **curr;
+	struct dhcp6_listval *v;
+	int elens[ARRAY_SIZE(client6_envp_list)];
+
+	envc = 3;    /* we at least include the interface, reason and the terminator */
+
+	/* count the number of variables & total env. length */
+	for (i=0; i < ARRAY_SIZE(client6_envp_list); i++) {
+	    sz = 0;
+	    v = TAILQ_FIRST(&optinfo->ad_list);
+	    while (v) {
+			if (v->dh6optype == client6_envp_list[i].type) {
+			    switch (v->lvtype) {
+				case DHCP6_LISTVAL_VBUF:
+				    sz += v->val_vbuf.dv_len + 1;
+				    break;
+				case DHCP6_LISTVAL_ADDR6:
+				    sz += INET6_ADDRSTRLEN + 1 + 1;
+				    break;
+				default:
+				    break;
+			    }
+			}
+			v = TAILQ_NEXT(v, link);
+	    }
+	    elens[i] = sz;
+	    envc += (sz ? 1 : 0);
+	}
+
+	/* allocate an environments array */
+	curr = envp = xzalloc(sizeof(char *) * envc);
+
+	/*
+	 * Copy the parameters as environment variables
+	 */
+	/* reason */
+	*curr = xstrdup("REASON=NBI");
+	putenv(*curr++);
+	/* interface name */
+	*curr = xasprintf("interface=%s", ifname);
+	putenv(*curr++);
+
+	/* "var=addr1 addr2 ... addrN" + null char for termination */
+	for (i=0; i < ARRAY_SIZE(client6_envp_list); i++) {
+	    if (elens[i] > 0) {
+			char a[INET6_ADDRSTRLEN];
+
+			elen = strlen(client6_envp_list[i].name) + 1 + elens[i];
+			*curr = xzalloc(elen);
+			sprintf(*curr, "%s=", client6_envp_list[i].name);
+
+			TAILQ_FOREACH(v, &optinfo->ad_list, link) {
+				if (v->dh6optype != client6_envp_list[i].type)
+					continue;
+				/* since we count total length above, it is safely to use strcat() */
+				switch (v->lvtype) {
+				    case DHCP6_LISTVAL_VBUF:
+					    strcat(*curr, v->val_vbuf.dv_buf);
+					    break;
+				    case DHCP6_LISTVAL_ADDR6:
+					    sprint_nip6(a, (const uint8_t *)&v->val_addr6);
+					    strcat(*curr, a);
+					    break;
+				    default:
+					    break;
+				}
+			    strcat(*curr, " ");
+			}
+			putenv(*curr++);
+	    }
+	}
+
+	return envp;
+}
+
+int dhcp6_script(const char *scriptpath, char **envp)
+{
+	char *argv[2];
+
+	/* if a script is not specified, do nothing */
+	if (!scriptpath[0])
+		return -2;
+
+	/* launch the script */
+	argv[0] = (char *)scriptpath;
+	argv[1] = NULL;
+	spawn_and_wait(argv);
+
+	/* free env */
+	if (envp != NULL) {
+		char **curr;
+
+		for (curr = envp; *curr; curr++) {
+			bb_unsetenv_and_free(*curr);
+		}
+		free(envp);
+	}
+	return 0;
+}
diff -urN busybox-1.36.1-ref/networking/udhcp/dhcp6c_socket.c busybox-1.36.1/networking/udhcp/dhcp6c_socket.c
--- busybox-1.36.1-ref/networking/udhcp/dhcp6c_socket.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.36.1/networking/udhcp/dhcp6c_socket.c	2023-05-19 23:01:27.861391752 +0300
@@ -0,0 +1,150 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2002 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <net/if.h>
+#include <netinet/in.h>
+
+#include "dhcp6c.h"
+
+#ifndef SO_REUSEPORT
+#define SO_REUSEPORT SO_REUSEADDR
+#endif
+
+int sock6_init(const char *boundaddr, const char *port)
+{
+	struct addrinfo hints, *res;
+	int err, sock;
+
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_family = PF_INET6;
+	hints.ai_socktype = SOCK_DGRAM;
+	hints.ai_protocol = IPPROTO_UDP;
+	hints.ai_flags = AI_PASSIVE;
+	err = getaddrinfo(boundaddr, port, &hints, &res);
+	if (err) {
+		bb_error_msg_and_die("getaddrinfo: %s", gai_strerror(err));
+	}
+	sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+	if (sock < 0) {
+		bb_perror_msg_and_die("socket");
+	}
+	if (setsockopt_SOL_SOCKET_1(sock, SO_REUSEPORT) < 0) {
+		bb_perror_msg_and_die("setsockopt(SO_REUSEPORT)");
+	}
+	socket_want_pktinfo(sock);
+#ifdef IPV6_V6ONLY
+	if (setsockopt_1(sock, IPPROTO_IPV6, IPV6_V6ONLY) < 0) {
+		bb_perror_msg_and_die("setsockopt(IPV6_V6ONLY)");
+	}
+#endif
+
+	/*
+	 * According RFC3315 2.2, only the incoming port should be bound to UDP
+	 * port 546.  However, to have an interoperability with some servers,
+	 * the outgoing port is also bound to the DH6PORT_DOWNSTREAM.
+	 */
+	xbind(sock, res->ai_addr, res->ai_addrlen);
+
+	freeaddrinfo(res);
+	return sock;
+}
+
+
+#ifdef __linux__
+/* from /usr/include/linux/ipv6.h */
+
+struct in6_ifreq {
+	struct in6_addr ifr6_addr;
+	uint32_t ifr6_prefixlen;
+	unsigned int ifr6_ifindex;
+};
+#endif /* __linux__ */
+
+int ifaddrconf(ifaddrconf_cmd_t cmd, const char *ifname, struct in6_addr *addr,
+	   int plen, int pltime UNUSED_PARAM, int vltime UNUSED_PARAM)
+{
+/*
+ * TODO: Should be rewritten to Netlink calls in order to support
+ *       preferred/valid lifetimes
+ */
+	struct in6_ifreq req;
+	struct ifreq ifr;
+	const char *cmdstr[] = {
+		[IFADDRCONF_ADD] "add",
+		[IFADDRCONF_REMOVE] "remove"
+	};
+	unsigned long ioctl_cmd;
+	struct sockaddr_in6 sin6;
+	int sk;
+	char *a;
+
+	switch (cmd) {
+	case IFADDRCONF_ADD:
+		ioctl_cmd = SIOCSIFADDR;
+		break;
+	case IFADDRCONF_REMOVE:
+		ioctl_cmd = SIOCDIFADDR;
+		break;
+	default:
+		return -1;
+	}
+
+	sk = xsocket(PF_INET6, SOCK_DGRAM, IPPROTO_UDP);
+	memset(&req, 0, sizeof(req));
+    memset(&sin6, 0, sizeof(sin6));
+    sin6.sin6_family = AF_INET6;
+#ifdef HAVE_SA_LEN
+    sin6.sin6_len = sizeof(struct sockaddr_in6);
+#endif
+    sin6.sin6_addr = *addr;
+
+	memset(&ifr, 0, sizeof(ifr));
+	strncpy_IFNAMSIZ(ifr.ifr_name, ifname);
+	xioctl(sk, SIOGIFINDEX, &ifr);
+	memcpy(&req.ifr6_addr, addr, sizeof(struct in6_addr));
+	req.ifr6_prefixlen = plen;
+	req.ifr6_ifindex = ifr.ifr_ifindex;
+
+	if (ioctl(sk, ioctl_cmd, &req)) {
+		if (errno == EEXIST) /* Ignore address duplicate */
+			goto out;
+		bb_perror_msg("can't %s address on %s", cmdstr[cmd], ifname);
+		close(sk);
+		return -1;
+	}
+
+	a = xmalloc_sockaddr2dotted_noport((struct sockaddr *)&sin6);
+	bb_error_msg("%s address %s/%d on %s", cmdstr[cmd], a, plen, ifname);
+	free(a);
+
+ out:
+	close(sk);
+	return 0;
+}
diff -urN busybox-1.36.1-ref/networking/udhcp/dhcpc.c busybox-1.36.1/networking/udhcp/dhcpc.c
--- busybox-1.36.1-ref/networking/udhcp/dhcpc.c	2023-01-03 16:14:43.000000000 +0200
+++ busybox-1.36.1/networking/udhcp/dhcpc.c	2023-05-19 23:01:27.861391752 +0300
@@ -75,6 +75,7 @@
 	"background\0"     No_argument       "b"
 	)
 	"broadcast\0"      No_argument       "B"
+	"daemon\0"         No_argument       "d"
 	IF_FEATURE_UDHCPC_ARPING("arping\0"	Optional_argument "a")
 	IF_FEATURE_UDHCP_PORT("client-port\0"	Required_argument "P")
 	;
@@ -103,9 +104,11 @@
 /* The rest has variable bit positions, need to be clever */
 	OPTBIT_B = 18,
 	USE_FOR_MMU(             OPTBIT_b,)
+	USE_FOR_MMU(             OPTBIT_d,)
 	IF_FEATURE_UDHCPC_ARPING(OPTBIT_a,)
 	IF_FEATURE_UDHCP_PORT(   OPTBIT_P,)
 	USE_FOR_MMU(             OPT_b = 1 << OPTBIT_b,)
+	USE_FOR_MMU(             OPT_d = 1 << OPTBIT_d,)
 	IF_FEATURE_UDHCPC_ARPING(OPT_a = 1 << OPTBIT_a,)
 	IF_FEATURE_UDHCP_PORT(   OPT_P = 1 << OPTBIT_P,)
 };
@@ -125,7 +128,9 @@
 	[OPTION_IP              ] = sizeof("255.255.255.255 "),
 	[OPTION_IP_PAIR         ] = sizeof("255.255.255.255 ") * 2,
 	[OPTION_STATIC_ROUTES   ] = sizeof("255.255.255.255/32 255.255.255.255 "),
+#if ENABLE_FEATURE_UDHCP_RFC5969
 	[OPTION_6RD             ] = sizeof("132 128 ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff 255.255.255.255 "),
+#endif
 	[OPTION_STRING          ] = 1,
 	[OPTION_STRING_HOST     ] = 1,
 #if ENABLE_FEATURE_UDHCP_RFC3397
@@ -296,6 +301,7 @@
 
 			return ret;
 		}
+#if ENABLE_FEATURE_UDHCP_RFC5969
 		case OPTION_6RD:
 			/* Option binary format (see RFC 5969):
 			 *  0                   1                   2                   3
@@ -338,6 +344,7 @@
 			}
 
 			return ret;
+#endif
 #if ENABLE_FEATURE_UDHCP_RFC3397
 		case OPTION_DNS_STRING:
 			/* unpack option into dest; use ret for prefix (i.e., "optname=") */
@@ -620,7 +627,10 @@
 {
 	int i, end, len;
 
-	udhcp_add_simple_option(packet, DHCP_MAX_SIZE, htons(IP_UDP_DHCP_SIZE));
+	len = sizeof(struct ip_udp_dhcp_packet);
+	if (client_data.client_mtu > 0)
+		len = MIN(client_data.client_mtu, len);
+	udhcp_add_simple_option(packet, DHCP_MAX_SIZE, htons(len));
 
 	/* Add a "param req" option with the list of options we'd like to have
 	 * from stubborn DHCP servers. Pull the data from the struct in common.c.
@@ -1177,6 +1187,7 @@
 //usage:     "\n	-A SEC		Wait if lease is not obtained (default 20)"
 //usage:	USE_FOR_MMU(
 //usage:     "\n	-b		Background if lease is not obtained"
+//usage:     "\n	-d		Background after run"
 //usage:	)
 //usage:     "\n	-n		Exit if lease is not obtained"
 //usage:     "\n	-q		Exit after obtaining lease"
@@ -1217,7 +1228,7 @@
 	llist_t *list_x = NULL;
 	int tryagain_timeout = 20;
 	int discover_timeout = 3;
-	int discover_retries = 3;
+	int discover_retries = 4;
 	uint32_t server_id = server_id; /* for compiler */
 	uint32_t requested_ip = 0;
 	int packet_num;
@@ -1246,6 +1257,7 @@
 		/* O,x: list; -T,-t,-A take numeric param */
 		"CV:F:i:np:qRr:s:T:+t:+SA:+O:*ox:*fB"
 		USE_FOR_MMU("b")
+		USE_FOR_MMU("d")
 		IF_FEATURE_UDHCPC_ARPING("a::")
 		IF_FEATURE_UDHCP_PORT("P:")
 		"v"
@@ -1344,7 +1356,8 @@
 	if (udhcp_read_interface(client_data.interface,
 			&client_data.ifindex,
 			NULL,
-			client_data.client_mac)
+			client_data.client_mac,
+			&client_data.client_mtu)
 	) {
 		return 1;
 	}
@@ -1355,6 +1368,13 @@
 		bb_daemonize_or_rexec(0 /* flags */, argv);
 		logmode = LOGMODE_NONE;
 	}
+#else
+	if (!(opt & OPT_f) && (opt & OPT_d) ) {
+		bb_daemonize(0);
+		logmode = LOGMODE_NONE;
+		/* do not background again! */
+		opt = ((opt & ~OPT_b) | OPT_f);
+	}
 #endif
 	if (opt & OPT_S) {
 		openlog(applet_name, LOG_PID, LOG_DAEMON);
@@ -1433,7 +1453,8 @@
 			if (udhcp_read_interface(client_data.interface,
 					&client_data.ifindex,
 					NULL,
-					client_data.client_mac)
+					client_data.client_mac,
+					&client_data.client_mtu)
 			) {
 				goto ret0; /* iface is gone? */
 			}
diff -urN busybox-1.36.1-ref/networking/udhcp/dhcpc.h busybox-1.36.1/networking/udhcp/dhcpc.h
--- busybox-1.36.1-ref/networking/udhcp/dhcpc.h	2021-09-30 01:04:47.000000000 +0300
+++ busybox-1.36.1/networking/udhcp/dhcpc.h	2023-05-19 23:01:27.861391752 +0300
@@ -9,6 +9,7 @@
 
 struct client_data_t {
 	uint8_t client_mac[6];          /* Our mac address */
+	uint16_t client_mtu;		/* Our mtu */
 	IF_FEATURE_UDHCP_PORT(uint16_t port;)
 	int ifindex;                    /* Index number of the interface to use */
 	uint32_t xid;
diff -urN busybox-1.36.1-ref/networking/udhcp/dhcpd.c busybox-1.36.1/networking/udhcp/dhcpd.c
--- busybox-1.36.1-ref/networking/udhcp/dhcpd.c	2023-01-03 16:14:43.000000000 +0200
+++ busybox-1.36.1/networking/udhcp/dhcpd.c	2023-05-19 23:01:27.861391752 +0300
@@ -958,7 +958,7 @@
 	if (udhcp_read_interface(server_data.interface,
 			&server_data.ifindex,
 			(server_data.server_nip == 0 ? &server_data.server_nip : NULL),
-			server_data.server_mac)
+			server_data.server_mac, NULL)
 	) {
 		retval = 1;
 		goto ret;
diff -urN busybox-1.36.1-ref/networking/udhcp/dhcprelay.c busybox-1.36.1/networking/udhcp/dhcprelay.c
--- busybox-1.36.1-ref/networking/udhcp/dhcprelay.c	2021-09-30 01:04:47.000000000 +0300
+++ busybox-1.36.1/networking/udhcp/dhcprelay.c	2023-05-19 23:01:27.865391616 +0300
@@ -294,7 +294,7 @@
 	max_socket = init_sockets(iface_list, num_sockets, fds);
 
 	/* Get our IP on server_iface */
-	if (udhcp_read_interface(argv[2], NULL, &our_nip, NULL))
+	if (udhcp_read_interface(argv[2], NULL, &our_nip, NULL, NULL))
 		return 1;
 
 	/* Main loop */
@@ -381,7 +381,7 @@
 //   of the 'giaddr' field does not match one of the relay agent's
 //   directly-connected logical interfaces, the BOOTREPLY message MUST be
 //   silently discarded.
-				if (udhcp_read_interface(iface_list[i], NULL, &dhcp_msg.gateway_nip, NULL)) {
+				if (udhcp_read_interface(iface_list[i], NULL, &dhcp_msg.gateway_nip, NULL, NULL)) {
 					/* Fall back to our IP on server iface */
 // this makes more sense!
 					dhcp_msg.gateway_nip = our_nip;
diff -urN busybox-1.36.1-ref/networking/udhcp/socket.c busybox-1.36.1/networking/udhcp/socket.c
--- busybox-1.36.1-ref/networking/udhcp/socket.c	2021-09-30 01:04:47.000000000 +0300
+++ busybox-1.36.1/networking/udhcp/socket.c	2023-05-19 23:01:27.865391616 +0300
@@ -25,7 +25,7 @@
 #include "common.h"
 #include <net/if.h>
 
-int FAST_FUNC udhcp_read_interface(const char *interface, int *ifindex, uint32_t *nip, uint8_t *mac)
+int FAST_FUNC udhcp_read_interface(const char *interface, int *ifindex, uint32_t *nip, uint8_t *mac, uint16_t *mtu)
 {
 	/* char buffer instead of bona-fide struct avoids aliasing warning */
 	char ifr_buf[sizeof(struct ifreq)];
@@ -70,6 +70,15 @@
 			mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
 	}
 
+	if (mtu) {
+		if (ioctl_or_warn(fd, SIOCGIFMTU, ifr) != 0) {
+			close(fd);
+			return -1;
+		}
+		log1("Adapter mtu %d", ifr->ifr_mtu);
+		*mtu = ifr->ifr_mtu;
+	}
+
 	close(fd);
 	return 0;
 }
diff -urN busybox-1.36.1-ref/networking/zcip.c busybox-1.36.1/networking/zcip.c
--- busybox-1.36.1-ref/networking/zcip.c	2021-01-01 12:52:27.000000000 +0200
+++ busybox-1.36.1/networking/zcip.c	2023-05-19 23:01:27.865391616 +0300
@@ -327,6 +327,7 @@
 	{
 		uint32_t t;
 		move_from_unaligned32(t, ((char *)&G.our_ethaddr + 2));
+		t += getpid();
 		srand(t);
 	}
 	// FIXME cases to handle:
diff -urN busybox-1.36.1-ref/sysklogd/syslogd.c busybox-1.36.1/sysklogd/syslogd.c
--- busybox-1.36.1-ref/sysklogd/syslogd.c	2021-01-01 12:52:27.000000000 +0200
+++ busybox-1.36.1/sysklogd/syslogd.c	2023-05-19 23:01:27.865391616 +0300
@@ -832,9 +832,9 @@
 	 && msg[9] == ':' && msg[12] == ':' && msg[15] == ' '
 	) {
 		if (!(option_mask32 & OPT_timestamp)) {
-			/* use message timestamp */
-			timestamp = msg;
-			now = 0;
+			// patch - use local time anyway
+			time(&now);
+			timestamp = ctime(&now) + 4; /* skip day of week */
 		}
 		msg += 16;
 	}
diff -urN busybox-1.36.1-ref/util-linux/fdisk.c busybox-1.36.1/util-linux/fdisk.c
--- busybox-1.36.1-ref/util-linux/fdisk.c	2023-01-03 16:14:43.000000000 +0200
+++ busybox-1.36.1/util-linux/fdisk.c	2023-05-19 23:01:27.869391480 +0300
@@ -484,10 +484,10 @@
 #define INIT_G() do { \
 	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
 	sector_size = DEFAULT_SECTOR_SIZE; \
-	sector_offset = 1; \
+	sector_offset = 2048; \
 	g_partitions = 4; \
 	units_per_sector = 1; \
-	dos_compatible_flag = 1; \
+	dos_compatible_flag = 0; \
 } while (0)
 
 
@@ -501,8 +501,8 @@
 	unsigned long longsectors;
 
 	if (ioctl(fd, BLKGETSIZE64, &v64) == 0) {
-		/* Got bytes, convert to 512 byte sectors */
-		v64 >>= 9;
+		/* Got bytes, convert to sectors */
+		v64 /= sector_size;
 		if (v64 != (sector_t)v64) {
  ret_trunc:
 			/* Not only DOS, but all other partition tables
@@ -1386,10 +1386,7 @@
 static void
 get_geometry(void)
 {
-	int sec_fac;
-
 	get_sectorsize();
-	sec_fac = sector_size / 512;
 #if ENABLE_FEATURE_SUN_LABEL
 	guess_device_type();
 #endif
@@ -1408,11 +1405,11 @@
 		kern_sectors ? kern_sectors : 63;
 	total_number_of_sectors = bb_BLKGETSIZE_sectors(dev_fd);
 
-	sector_offset = 1;
+	sector_offset = 2048;
 	if (dos_compatible_flag)
 		sector_offset = g_sectors;
 
-	g_cylinders = total_number_of_sectors / (g_heads * g_sectors * sec_fac);
+	g_cylinders = total_number_of_sectors / g_heads / g_sectors;
 	if (!g_cylinders)
 		g_cylinders = user_cylinders;
 }
@@ -1800,7 +1797,7 @@
 		sector_offset = g_sectors;
 		printf("DOS Compatibility flag is %sset\n", "");
 	} else {
-		sector_offset = 1;
+		sector_offset = 2048;
 		printf("DOS Compatibility flag is %sset\n", "not ");
 	}
 }
@@ -2028,7 +2025,7 @@
 static void
 list_disk_geometry(void)
 {
-	ullong xbytes = total_number_of_sectors / (1024*1024 / 512);
+	ullong xbytes = total_number_of_sectors / (1024*1024 / sector_size);
 	char x = 'M';
 
 	if (xbytes >= 10000) {
@@ -2041,7 +2038,7 @@
 		"Units: %ss of %u * %u = %u bytes\n"
 		"\n",
 		disk_device, xbytes, x,
-		((ullong)total_number_of_sectors * 512), total_number_of_sectors,
+		((ullong)total_number_of_sectors * sector_size), total_number_of_sectors,
 		g_cylinders, g_heads, g_sectors,
 		str_units(),
 		units_per_sector, sector_size, units_per_sector * sector_size
diff -urN busybox-1.36.1-ref/util-linux/mdev.c busybox-1.36.1/util-linux/mdev.c
--- busybox-1.36.1-ref/util-linux/mdev.c	2023-01-03 16:14:43.000000000 +0200
+++ busybox-1.36.1/util-linux/mdev.c	2023-05-19 23:01:27.869391480 +0300
@@ -565,7 +565,8 @@
 
 /* mknod in /dev based on a path like "/sys/block/hda/hda1"
  * NB1: path parameter needs to have SCRATCH_SIZE scratch bytes
- * after NUL, but we promise to not mangle it (IOW: to restore NUL if needed).
+ * after NUL, but we promise to not mangle (IOW: to restore NUL if needed)
+ * path string.
  * NB2: "mdev -s" may call us many times, do not leak memory/fds!
  *
  * device_name = $DEVNAME (may be NULL)
@@ -576,6 +577,16 @@
 	int major, minor, type, len;
 	char *path_end = path + strlen(path);
 
+	/* fix create char device /dev/mtdX as block device (child for /dev/mtdblockX) */
+	if (strcmp((char*) bb_basename(path), "device") == 0) {
+		return;
+	}
+
+	/* fix create char device /dev/mtdX as block device (child for /dev/mtdblockX) */
+	if (strcmp((char*) bb_basename(path), "device") == 0) {
+		return;
+	}
+
 	/* Try to read major/minor string.  Note that the kernel puts \n after
 	 * the data, so we don't need to worry about null terminating the string
 	 * because sscanf() will stop at the first nondigit, which \n is.
@@ -831,48 +842,39 @@
 	} /* for (;;) */
 }
 
-static ssize_t readlink2(char *buf, size_t bufsize)
-{
-	// Grr... gcc 8.1.1:
-	// "passing argument 2 to restrict-qualified parameter aliases with argument 1"
-	// dance around that...
-	char *obuf FIX_ALIASING;
-	obuf = buf;
-	return readlink(buf, obuf, bufsize);
-}
-
-/* File callback for /sys/ traversal.
- * We act only on "/sys/.../dev" (pseudo)file
- */
+/* File callback for /sys/ traversal */
 static int FAST_FUNC fileAction(struct recursive_state *state,
 		const char *fileName,
 		struct stat *statbuf UNUSED_PARAM)
 {
 	size_t len = strlen(fileName) - 4; /* can't underflow */
-	char *path = state->userData;	/* char array[PATH_MAX + SCRATCH_SIZE] */
-	char subsys[PATH_MAX];
-	int res;
-
-	/* Is it a ".../dev" file? (len check is for paranoid reasons) */
-	if (strcmp(fileName + len, "/dev") != 0 || len >= PATH_MAX - 32)
-		return FALSE; /* not .../dev */
-
-	strcpy(path, fileName);
-	path[len] = '\0';
-
-	/* Read ".../subsystem" symlink in the same directory where ".../dev" is */
-	strcpy(subsys, path);
-	strcpy(subsys + len, "/subsystem");
-	res = readlink2(subsys, sizeof(subsys)-1);
-	if (res > 0) {
-		subsys[res] = '\0';
+	char *scratch = state->userData;
+
+	/* len check is for paranoid reasons */
+	if (strcmp(fileName + len, "/dev") != 0 || len >= PATH_MAX)
+		return FALSE;
+
+	strcpy(scratch, fileName);
+	scratch[len] = '\0';
+	make_device(/*DEVNAME:*/ NULL, scratch, OP_add);
+
+	return TRUE;
+}
+
+/* Directory callback for /sys/ traversal */
+static int FAST_FUNC dirAction(struct recursive_state *state,
+		const char *fileName UNUSED_PARAM,
+		struct stat *statbuf UNUSED_PARAM)
+{
+	/* Extract device subsystem -- the name of the directory
+	 * under /sys/class/ */
+	if (1 == state->depth) {
 		free(G.subsystem);
 		if (G.subsys_env) {
 			bb_unsetenv_and_free(G.subsys_env);
 			G.subsys_env = NULL;
 		}
-		/* Set G.subsystem and $SUBSYSTEM from symlink's last component */
-		G.subsystem = strrchr(subsys, '/');
+		G.subsystem = strrchr(fileName, '/');
 		if (G.subsystem) {
 			G.subsystem = xstrdup(G.subsystem + 1);
 			G.subsys_env = xasprintf("%s=%s", "SUBSYSTEM", G.subsystem);
@@ -880,16 +882,6 @@
 		}
 	}
 
-	make_device(/*DEVNAME:*/ NULL, path, OP_add);
-
-	return TRUE;
-}
-
-/* Directory callback for /sys/ traversal */
-static int FAST_FUNC dirAction(struct recursive_state *state,
-		const char *fileName UNUSED_PARAM,
-		struct stat *statbuf UNUSED_PARAM)
-{
 	return (state->depth >= MAX_SYSFS_DEPTH ? SKIP : TRUE);
 }
 
@@ -910,8 +902,7 @@
 	int firmware_fd, loading_fd;
 
 	/* check for /lib/firmware/$FIRMWARE */
-	firmware_fd = -1;
-	if (chdir("/lib/firmware") == 0)
+	xchdir("/lib/firmware");
 		firmware_fd = open(firmware, O_RDONLY); /* can fail */
 
 	/* check for /sys/$DEVPATH/loading ... give 30 seconds to appear */
@@ -1143,8 +1134,23 @@
 
 	putenv((char*)"ACTION=add");
 
-	/* Create all devices from /sys/dev hierarchy */
-	recursive_action("/sys/dev",
+	/* ACTION_FOLLOWLINKS is needed since in newer kernels
+	 * /sys/block/loop* (for example) are symlinks to dirs,
+	 * not real directories.
+	 * (kernel's CONFIG_SYSFS_DEPRECATED makes them real dirs,
+	 * but we can't enforce that on users)
+	 */
+	if (access("/sys/class/block", F_OK) != 0) {
+		/* Scan obsolete /sys/block only if /sys/class/block
+		 * doesn't exist. Otherwise we'll have dupes.
+		 * Also, do not complain if it doesn't exist.
+		 * Some people configure kernel to have no blockdevs.
+		 */
+		recursive_action("/sys/block",
+			ACTION_RECURSE | ACTION_FOLLOWLINKS | ACTION_QUIET,
+			fileAction, dirAction, temp);
+	}
+	recursive_action("/sys/class",
 			 ACTION_RECURSE | ACTION_FOLLOWLINKS,
 			 fileAction, dirAction, temp);
 }
diff -urN busybox-1.36.1-ref/util-linux/volume_id/get_devname.c busybox-1.36.1/util-linux/volume_id/get_devname.c
--- busybox-1.36.1-ref/util-linux/volume_id/get_devname.c	2021-01-01 12:52:27.000000000 +0200
+++ busybox-1.36.1/util-linux/volume_id/get_devname.c	2023-05-19 23:01:27.869391480 +0300
@@ -305,17 +305,20 @@
 
 int resolve_mount_spec(char **fsname)
 {
-	char *tmp = *fsname;
+	char *tmp = NULL;
 
 	if (is_prefixed_with(*fsname, "UUID="))
 		tmp = get_devname_from_uuid(*fsname + 5);
 	else if (is_prefixed_with(*fsname, "LABEL="))
 		tmp = get_devname_from_label(*fsname + 6);
-
-	if (tmp == *fsname)
+	else {
+		*fsname = xstrdup(*fsname);
 		return 0; /* no UUID= or LABEL= prefix found */
+	}
+
+	if (!tmp)
+		return -2; /* device defined by UUID= or LABEL= wasn't found */
 
-	if (tmp)
 		*fsname = tmp;
 	return 1;
 }
diff -urN busybox-1.36.1-ref/util-linux/volume_id/linux_swap.c busybox-1.36.1/util-linux/volume_id/linux_swap.c
--- busybox-1.36.1-ref/util-linux/volume_id/linux_swap.c	2021-01-01 12:52:27.000000000 +0200
+++ busybox-1.36.1/util-linux/volume_id/linux_swap.c	2023-05-19 23:01:27.873391344 +0300
@@ -61,6 +61,7 @@
 			if (memcmp(buf, "SWAPSPACE2", 10) == 0
 			 || memcmp(buf, "S1SUSPEND", 9) == 0
 			 || memcmp(buf, "S2SUSPEND", 9) == 0
+			 || memcmp(buf, "LINHIB0001", 10) == 0
 			 || memcmp(buf, "ULSUSPEND", 9) == 0
 			) {
 				sw = volume_id_get_buffer(id, off, sizeof(struct swap_header_v1_2));
